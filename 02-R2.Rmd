# RStudio & das tidyverse {#R2}

``` {r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(cache.path = 'cache/')
```

## RStudio workflow

Im vorangegangen Kapitel haben wir unsere Befehle direkt in die R console
eingegeben, mit “Enter” bestätigt und unseren output zurückbekommen. Dies
funktioniert, ist aber auf lange Sicht nicht zuriedenstellend. Das Hauptproblem
besteht darin, dass unser code nach dem Ausführen nicht erhalten bleibt. Wir
können zwar durch die console scrollen um nachzuvollziehen, welche Befehle wir
genutzt haben, dies ist uns aber spätestens nach dem Schließen von RStudio nicht
mehr zugänglich. In der Realität werden Sie aber häufig längere Zeiträume an
einem Projekt arbeiten und möchten eventuell ihren code mit Kommiliton:innen,
Kolleg:innen oder der R community teilen. Je komplexer unser code wird, desto
mehr Fehler werden wir auch machen. Ein früher Fehler in der console der erst
spät auffällt kann bedeuten, dass der Großteil unserer Arbeit wiederholt werden
müsste.


### R scripts

Ein R script ist eine Datei in der wir unsere Befehle niederschreiben und so für
die spätere Weiterarbeit und Weitergabe dokumentieren.

Um ein neues R script zu erstellen klicken Sie auf "File" > "New File" > "R
Script", oder nutzen Sie die praktische Tastenkombination "CTRL" + "Shift" +
"N". So wird ein leeres und unbenanntes neues script erstellt.

Als erste Übung können wir ein Stück code aus dem vorangegangenen Kapitel statt
in der console in unser R script eingeben.

``` {r script_example}
a <- 17
b <- 4

the_answer <- (a + b) * 2

the_answer
```

Zur Erinnerung, wir erstellen zwei numerische Objekte a und b, weisen das
Ergebnis einer Berechnung mit diesen zwei Objekten einem neuem Objekt
`the_answer` zu und lassen uns dieses Objekt, also das Ergebnis der Berechnung,
ausgeben.

Statt die Befehle Zeile für Zeile in die console einzugeben und jede Zeile
direkt auszuführen, schreiben wir zunächst den kompletten code block in unser
neues script. Danach können wir unser komplettes script durch einen Klick auf
"Source" in der toolbar des script Fensters ausführen. Ich empfehle Ihnen
stattdessen aber, scripts stets Befehl für Befehl auszuführen. So haben Sie die
volle Kontrolle über den Prozess, sehen sofort das Ergebnis (oder den Fehler)
jedes einzelnen Befehls und können die Ausführung an jeder beliebigen Stelle
pausieren, zum Beispiel um den Code besser nachzuvollziehen, Fehler zu erkennen
oder Veränderungen vorzunehmen. Umsetzen können Sie dies mit einem Klick auf
"Run" in der Toolbar des Scripttabs oder noch einfacher durch das Drücken von
"CTRL" + "Enter". In beiden Fällen wird die Zeile in der sich aktuell Ihr Cursor
befindet ausgeführt. Dieser springt daraufhin automatisch in die nächste Zeile,
so dass Sie auch Befehl für Befehl schnell ihr ganzes script ausführen können,
dabei aber die volle Kontrolle behalten. Was für Sie praktikabler ist, müssen
Sie selbst entscheiden und kann auch von der Situation abhängen. Bedenken Sie
aber immer, dass R zu jeden Zeitpunkt davon ausgeht, dass Sie wissen was Sie
tun. Es wird keine Warnmeldungen geben, wenn Sie etwas überschreiben das Sie
eigentlich nicht überschreiben wollten.

Sie sollten ihr script regelmäßig abspeichern. Nicht nur dann wenn Sie eine
Arbeitssession beenden, sondern *regelmäßig*. Dies können sie über "File" >
"Save" erreichen oder durch die Tastenkombination "CTRL" + "S". Sie können den
Namen des scripts frei wählen, die Endung muss jedoch immer ".R" sein.

Ein Problem, dass Ihnen früher oder später begegnen wird, ist dass Sie
versehentlich versuchen werden inkompletten code aus einem script auszuführen.
Der Grund ist sehr häufig eine fehlende schließende Klammer, wie in
`print("Hello World"`. R kann den code nicht interpretieren und geht aufgrund
der fehlenden Klammer davon aus, dass der code noch weitergehen soll. R
übernimmt dann den inkompletten code in die console, führt ihn aber nicht aus
sondern beginnt eine neue Zeile mit einem `+`. Dies bedeutet, dass wir hinter
dem `+` den code fortsetzen können. In der Regel ist es dann am praktikabelsten
die Ausführung des codes abzubrechen indem sie in die console klicken und danach
"Esc" drücken. Dann können wir den code in unserem script korrigieren und erenut
ausführen.


### Projekte

Häufig werden unsere R Vorhaben aus mehreren Dateien -- wie scripts, Datensätzen
oder ausgegebenen Graphiken -- bestehen. Es macht dann häufig Sinn, diese
Dateien an einem gemeinsamen Ort abzuspeichern. Dies können wir natürlich "per
Hand" managen, hier aber kann RStudio’s Projektfunktion sehr hilfreich sein.

Durch Klicken auf "File" > "New Project", erstellen wir ein neues Projekt. Haben
wir bereits einen Ordner für das Projekt angelegt, können wir auf "Existing
Directory" klicken, den Ordner auswählen und die Erstellung mit "Create Project"
abschließen. Oder wir erstellen mit "New Directory" > "New Project" einen neuen
Ordner für das Projekt direkt aus RStudio.

RStudio wird nun alle aktuell geöffneten Dateien schließen und in das neu
erstellte Projekt wechseln. Der Name des gewählten oder erstellten Ordners ist
auch gleichzeitig der Name des Projekts, angezeigt in der Titelleiste von
RStudio. Der "Files" tab (rechts-unten) zeigt nun auch den Inhalt des
Projektordners. Dies ist ihr aktuelles working directory, mehr dazu gleich. Sie
können nun Dateien erstellen und bearbeiten und speichern diese ganz normal ab.
Das Projekt selbst muss nie gespeichert werden. Möchten Sie in einer späteren R
Session ihre Arbeit an dem Projekt fortsetzen, klicken Sie auf "File" > "Open
Project". Das Projekt wird geöffnet, alle Dateien die Sie bei der letzten
Session geöffnet hatten sind erneut geöffnet und Sie befinden sich auch wieder
im working directory des Projekts. Projekte sind eine einfache und praktische
Methode um Ihre Arbeiten zu organisieren und aufgeräumt zu halten.

An dieser Stelle wäre es eventuell sinnnvoll, wenn Sie ein Projekt zu diesem
Seminar erstellen. Sie könnten dann scripts für jedes Kapitel anlegen oder
weitere Unterordner für Übungen usw. einrichten. Ob dies für Sie eine sinnvolle
Arbeitsweise ist, bleibt aber Ihnen überlassen.

Wir sollten nun noch kurz über das *working directory* sprechen. Dieses wird zum
Beispiel dann relevant, wenn Sie versuchen eine Datei direkt aus einem script
heraus zu öffnen oder zu speichern. Geben Sie dabei keinen kompletten absoluten
Pfad an, geht R immer davon aus, dass Sie sich auf das working directory
beziehen. Arbeiten Sie in einem Projekt, ist das working directory automatisch
das Hauptverzeichnis des Projekts. Mit `getwd()` gibt Ihnen R ihr aktuelles
Arbeitsverzeichnis zurück. Ihr Arbeitsverzeichnis können Sie über "Session" >
"Set Working Directory" > "Choose Directory..." oder mit der Funktion `setwd()`
ändern, wobei der Pfad mit `""` eingefasst zwischen die Klammern geschrieben
wird.


### Kommentare

Einer der wichtigsten skills beim Schreiben von code, ist das Kommentieren des
selbigen. Kommentare können wir direkt in scripts schreiben, diese werden jedoch
nicht ausgeführt sondern dienen der Erläuterung und Strukturierung des codes.
Einen Kommentar markieren wir mit einem oder mehreren `#`. Text der auf ein `#`
folgt wird von R als Kommentar erkannt und entsprechend nicht ausgeführt.

Wenn Sie über längere Zeit an einem Projekt arbeiten oder dieses nach längerer
Zeit erneut öffnen, kann es für sie selbst manchmal schwierig sein
nachzuvollziehen, was Sie mit ihrem code erreichen wollten. Gut kommentierter
code erleichtert dies stark. Dies wird nochmals relevanter, wenn Sie ihren code
mit anderen Personen teilen. Für die meisten Probleme in R bestehen eine
Vielzahl möglicher Ansätze. Gut kommentierter code hilft Anderen zu verstehen,
was *ihr* Ansatz ist. Hier können Sie die Zeit die Sie in das Kommentieren
investieren als Respekt gegenüber der Zeit verstehen, die Andere investieren um
Ihnen mit Ihrem code zu helfen.

Ihnen wird eventuell aufgefallen sein, dass der output der code Blöcke auf
dieser website mit `##` beginnt. Im output Ihrer R console fehlen diese. Beim
Erstellen der website mit dem package **bookdown** werden die Symbole
automatisch im output eingefügt um das Kopieren und Einfügen der code Blöcke in
Ihre scripts zu erleichtern. So wird der mit `##` markierte output von R als
Kommentar verstanden und nicht als Befehl ausgeführt. Dies ist oft praktisch,
trotzdem empfehle ich weiterhin so viel wie möglich selbst zu Tippen und
copy/paste spärlich zu verwenden.

Hier ein Beispiel eines bereits bekannten code Blocks, diesmal mit Kommentaren
versehen:

``` {r script_example_commented}
# assigning objects
a <- 17
b <- 4

# calculating the answer
the_answer <- (a + b) * 2

the_answer
# but what is the question?
```

Verwenden Sie `setwd()` in Ihrem script, empfiehlt es sich, dies
auszukommentieren bevor sie das script weitergeben. Andere Personen haben andere
Ordnerstrukturen als Sie und können mit Ihrem individuellen `setwd()` nichts
anfangen. Im besten Fall wird ihr `setwd()` nicht ausführbar sein, im
schlechtesten bringen Sie die Ordnerstruktur einer anderen Person durcheinander.
Ähnliches gilt für Befehle die etwas auf die Festplatte speichern,
beispielsweise Datensätze oder exportierte Graphiken. Die R community ist
grundsätzlich sehr bereitwillig auch Anfängern mit coding Problemen zu helfen.
Wir sollten diese Bereitschaft damit würdigen gut kommentierten code
weiterzugeben und davon abzusehen, in die Dateistruktur anderer Personen
einzugreifen.

### Speichern

Aus dem Blickwinkel reproduzierbarer Datenanalyse ist es aus meiner Sicht meist
der beste Ansatz, ein script zu erstellen in dem die rohen Daten eingelesen,
bereinigt, transformiert sowie statistisch und graphisch analysiert werden. So
ist es jeder Person mit Zugriff auf die Daten und ihr script möglich, jeden
ihrer Arbeitsschritte nachzuvollziehen und zu reproduzieren. Dies ist eine der
Säulen transparenter wissenschaftlicher Praxis. Bei diesem Ansatz müssen wir
also selten die Ergebnisse unserer Analysen als Datensatz abspeichern. Das
script -- die ".R" Datei -- ist ausreichend.

Es gibt aber auch Situationen in denen es sinnvoll sein kann, Ergebnisse
abzuspeichern. Quantitative Textanalysen können bespielsweise sehr
rechenintensiv sein. Bei der Anwendung fortgeschrittener Methoden im machine
learning auf sehr große Datensätze, können schonmal mehrere Stunden bis Tage
Rechenzeit anfallen. Auch wenn wir solche Zeitdmensionen in diesem Seminar nicht
erreichen, kann es hilfreich sein auch die Ergebnisse einer Operation im
niedrigen Minutenbereich abzuspeichern um Rechenzeit bei regelmäßiger Arbeit mit
den Ergebnissen zu sparen.

Die einfachste Möglichkeit ist es, zum Speichern das native R Datenformat
".RData" zu nutzen.

Erstellen wir einen kurzen data frame um diesen gleich abzuspeichern:

``` {r example_df}
data <- data.frame(
  name = c("Peter", "Paul", "Mary"),
  age = c(42, 84, 24),
  size = c(1.68, 1.82, 1.74),
  retired = c(FALSE, TRUE, FALSE)
)
```

Mit `save()` können wir ".RData" Dateien speichern. Dazu schreiben wir innerhalb
der Klammern zunächst den Namen des Objekts -- oder mehrerer Objekte mit `c()`
zusammengefasst -- gefolgt von einem `,` und dem Argument `file = ""`. Innerhalb
der `""` legen wir einen Dateinamen mit einem optionalen Pfad fest. Eine Datei
ohne angegebenen Pfad wird im aktuellen working directory gespeichert.

``` {r df_save}
save(data, file = "peter_paul_mary.RData")
```

Um die gespeicherten Daten wieder zu laden, nutzen wir die Funktion `load()` mit
dem Namen beziehungsweise Pfad der Datei als einzigem Argument.

``` {r df_load}
load("peter_paul_mary.RData")
```

So haben wir Daten in dem schnellen und gut komprimierten nativen ".RData"
Format gespeichert. Der Nachteil ist, dass diese Daten auch nur in R genutzt
werden können. Interessieren sie sich dafür, Daten in einem besser
transportierbaren Format zu speichern, bietet sich ".csv" an. Mehr dazu in
Kapitel \@ref(export) sowie hier:
<https://jakobtures.github.io/web-scraping/files.html>{target="_blank"}


## tidyverse

Weiter oben haben wir das **tidyverse** package installiert und geladen. Dieses
wird uns durch das ganze Seminar begleiten. Das tiydverse ist eine beliebte
Sammlung von R packages die einer gemeinsamen Philosophie der Funktionssyntax
sowie der Datenstruktur folgen und dabei viele datenanalytische Arbeitsprozesse
abdecken. Der Vorteil ist, dass Sie, sobald Sie die Grundlogik verstanden haben,
sehr schnell auch weitere tidyverse packages verstehen werden. Letztlich ist es
Geschmackssache, aber aus meiner Sicht führt das Arbeiten mit dem tidyverse zu
intuitiverem und flüßiger zu schreibendem R code, vor allem dank der pipe `%>%`.

Aktuell besteht das core **tidyverse** package aus acht individuellen packages.
Diese werden alle automatisch geladen wenn wir `library(tidyverse)` schreiben.
Das core **tidyverse** deckt einen Großteil der besonders regelmäßig
auftretenden datenanalytischen Funktionalitäten ab. Dazu gehören das Einlesen,
Reinigen und Transformieren von Daten, die angesprochene pipe oder die
graphische Analyse. Im weiteren werden wir viele Funktionen aus dem core
**tidyverse** sehr regelmäßig nutzen.

Nebem dem core **tidyverse** besteht eine wachsende Zahl zugehöriger packages,
welche nach den selben Grundsätzen funktionieren, dabei aber speziellere
Aufgabenfelder abdecken. Auch diese wurden mit `install.packages("tidyverse")`
bereits installiert, müssen aber explizit geladen werden. Darunter
beispielsweise **lubridate** zum Umgang mit Datumsangaben und eine Reihe von
packages zum Einlesen bestimmter Datentypen.

Eine volle Liste der tidyverse packages finden Sie unter: <https://www.tidyverse.org/packages/>{target="_blank"}

Für eine umfassendere Einführung in das tidyverse bietet sich das Buch "R for
Data Science" von Wickham & Grolemund an, welches auch Online zugänglich ist:
<https://r4ds.had.co.nz/>{target="_blank"}


### tidy data

Das tidyverse folgt einer geteilten Philosophie der Datenstruktur namens
*tidy data*. Einfach ausgedrückt steht tidy data dafür, dass jede Variable eines
Datensatz eine eigene Spalte in einer Tabelle bekommt und jede Beobachtung eine
eigene Zeile. Die Werte zu den Kombinationen von Variablen und Beobachtungen
stehen dann logisch folgend in den Zellen.

Betrachten wir folgenden data frame, welcher aktuelle (04.09.2021) Umfragewerte
für die Wahl zum 20. Bundestag enthält. Die Daten stammen von:
<https://www.wahlrecht.de/umfragen/index.htm>{target="_blank"}

``` {r untidy_data, echo = FALSE}
data.frame(
  Institut = c("Kantar", "Infratest"),
  CDU_CSU = c(21, 20),
  SPD = c(25, 25),
  GRÜNE = c(19, 16),
  FDP = c(11, 13),
  LINKE = c(7, 6),
  AfD = c(11, 12),
  Sonstige = c(6, 8)
)
```

Diese Darstellungsform ist uns sofort intuitiv verständlich. So sehen Tabellen
in Excel oder in Zeitungen aus und die Darstellung ist kompakt und
übersichtlich. Aber ist Sie auch *tidy*? Dazu müssen wir uns Gedanken darüber
machen, welche Variablen die Tabelle enthält. Die erste Spalte bildet die
Variable "Institut" ab. Dies macht Sinn. Die restlichen 7 Spalten enthalten die
Umfragewerte für die 6 aktuell im Bundestag vertretenen Parteien sowie
"Sonstige". Wir haben also eigentlich 2 Variablen: "Umfragewert" und "Partei",
welche aktuell in 7 Spalten dargestellt werden. Sie erinnern sich, jede Variable
bekommt in einem tidy Datensatz eine Spalte. Zudem werden die Werte der Variable
"Partei" auch gar nicht als Werte in der Tabelle sondern in den Spaltennamen
abgebildet. Die Tabelle ist also eindeutig nicht tidy.

Vergleichen Sie dies zu folgendem data frame:

``` {r tidy_data, echo = FALSE}
data.frame(
  Institut = c("Kantar", "Kantar", "Kantar", "Kantar", "Kantar", "Kantar", "Kantar",
               "Infratest", "Infratest", "Infratest", "Infratest", "Infratest", "Infratest", "Infratest"),
  Partei = c("CDU_CSU", "SPD", "GRÜNE", "FDP", "LINKE", "AfD", "Sonstige"),
  Umfragewert = c(21, 25, 19, 11, 7, 11, 6, 20, 25, 16, 13, 6, 12, 8)
)
```

Diese Darstellung ist tidy. Wir haben 3 Variablen "Institut", "Partei" und
"Umfragewert" die jeweils in einer eigenen Spalte stehen. Beobachtungen sind
nun nicht mehr das komplette Set von Umfragewerten eines Umfrageinstituts,
sondern der Umfragewert einer Partei bei einem Insitut. Das Ergebnis ist eine
Tabelle die den Prinzipien der tidy data folgt, die uns auf den ersten Blick
aber seltsam erscheint, da wir nicht daran gewohnt sind Daten in dieser Form
darzustellen. Wir sollten aber auch bedenken, dass es an dieser Stelle nicht das
Ziel ist eine schöne Tabelle für menschliche Leser zu präsentieren sondern ein
Datenobjekt zu konstruieren, welches uns die praktische und komfortabele
Weiterarbeit mit den diversen tidyverse packages ermöglicht.

Mehr zu den angedeuteten Prinzipien der tidy data finden Sie im entsprechenden
Kapitel von "R for Data Science" von Wickham & Grolemund:
<https://r4ds.had.co.nz/tidy-data.html.>{target="_blanK"}


### Tibbles

Das **tibble** package ist Teil des core **tidyverse** und bietet eine
Alternative zur base R Darstellung von Tabellen als data frames. Dabei liegen
viele der Unterschiede zwischen tibbles und data frames eher im Detail. Für uns
sind vor allem die Art wie tibbles in die console gedruckt werden und wie das
subsetting funktioniert relevant. Mehr zu Beidem gleich. Eine ausführlichere
Einführung finden Sie erneut in "R for Data Science":
<https://r4ds.had.co.nz/tibbles.html>{target="_blank"}

Tibbles erstellen wir dabei auf die selbe Weise wie data frames, nutzen dazu
aber die Funktion `tibble()`. Dazu müssen wir zunächst das **tibble**
beziehungsweise das **tidyverse** package, welches **tibble** enthält, laden.
Das Laden von packages sollte in den ersten Zeilen eines scripts passieren. So
werden alle notwendigen packages zu Beginn eines scripts geladen und andere
Nutzer*innen sehen sofort welche packages eventuell noch nachinstalliert werden
müssen. 

Hier geben wir die Daten direkt bei der Erstellung des tibbles ein. Wie bei data
frames können wir tibbles aber auch aus zuvor definierten Vektoren
zusammensetzen.

``` {r tibble_1}
library(tidyverse)

tibble(numbers = c(0, 1, 2), strings = c("zero", "one", "two"), logicals = c(FALSE, TRUE, TRUE))
```

Bevor wir den ouput betrachten, ein genereller Hinweis: Je länger unser code
wird, desto unübersichtlicher wird er auch. Wir sollten längeren code deshalb
über mehrere Zeilen aufteilen und durch Einrücken kennzeichnen welche code
Segmente zusammengehörig sind. Das Einrücken übernimmt RStudio weitestgehend
automatisch, wir können aber auch selbst tab stops hinzufügen oder entfernen um
Zeilen einzurücken. Eine übersichtlicher formatierte, inhaltlich aber identische
Version des vorangegangenen codes könnte wie folgt aussehen:

``` {r tibble_2}
tibble(
  numbers = c(0, 1, 2),
  strings = c("zero", "one", "two"),
  logicals = c(FALSE, TRUE, TRUE)
)
```

R interpretiert dies identisch zur Schreibweise in einer Zeile und weiß, dass
alles zwischen der öffnenden und schließenden Klammer Teil der aufgerufenen
Funktion ist.

Lassen sie uns nun den output betrachten. Dieser ist grundsätzlich ähnlich zu
dem output eines data frames, wobei 2 Unterschiede bestehen. Zum Einen wird der
Datentyp einer Spalte unter deren Namen abgebildet. Zum Anderen werden längere
tibbles verkürzt abgedruckt, wie wir später noch sehen werden. Data frames
werden hingegen stets vollständig gedruckt, was bei großen Datenmengen nur dazu
führt, dass in der console eigentlich nichts mehr lesbar ist. 

Ein weiterer wichtiger Unterschied besteht im subsetting von tibbles. Das
subsetting mit `[]` gibt uns immer einen neuen tibble zurück, mit `[[]]`
bekommen wir einen Vektor. Sind wir nur an Spalten interessiert, reicht es
übrigens nur die Spaltenposition zwischen den Klammern einzutragen. So bekommen
wir die komplette Spalte, also über alle Zeilen, zurück. Alternativ zur 
numerischen Position, können wir auch die Spaltennamen nutzen. Entweder zwischen
den eckigen Klammern oder in der $-Notation.

``` {r tibble_3}
tbl_exmpl <- tibble(
  numbers = c(0, 1, 2),
  strings = c("zero", "one", "two"),
  logicals = c(FALSE, TRUE, TRUE)
)

str(tbl_exmpl[1])
str(tbl_exmpl[[1]])
str(tbl_exmpl[["numbers"]])
str(tbl_exmpl$numbers)
```

Viele tidyverse Funktionen nutzen tibbles statt data frames -- so auch die
Funktionen des **tidytext** packages, welches wir im Verlaufe des Seminars
ausgiebig nutzen werden --, und Funktionen aus anderen packages werden meist
data frames zurückgeben. Wir können beide Datenobjekte aber auch konvertieren.
Dazu nutzen wir die base R Funktion `as.data.frame()` bzw. die **dplyr**
Funktion `as_tibble()`.

``` {r tibble_4}
str(tbl_exmpl)

df_exmpl <- as.data.frame(tbl_exmpl)
str(df_exmpl)

tbl_exmpl_2 <- as_tibble(df_exmpl)
str(tbl_exmpl_2)
```


### Die Pipe `%>%`

Ein weiteres Element des tidyverse ist die sogenannte pipe `%>%`. Diese
ermöglicht das Aneinanderketten von Befehlen, wobei das Ergebnis des
vorangegangenen Befehls an den nächsten weitergegeben wird. Dies klingt noch
sehr abstrakt, betrachten wir also ein praktisches Beispiel.

Folgender code hat das Ziel, für einen Vektor von Zahlen den auf eine
Nachkommastelle gerundeten Mittelwert zu berechnen. Dazu müssen wir zunächt den
Vektor erstellen und einem Objekt zuweisen, dann den Mittelwert berechnen und
erneut einem Objekt zuweisen und in einem letzten Schritt das Runden mit der
Funktion `round()` vornehmen. Das Argument `digits =` legt dabei die Anzahl der
Nachkommastellen fest.


``` {r no_pipe}
data <- c(4.8, 15.16, 23.42)
mean_data <- mean(data)
round(mean_data, digits = 1)
```

Dies funktioniert, wir mussten dazu aber auch jeden Zwischenschritt in ein neues
Objekt speichern. Nutzen wir stattdessen die pipe, umgehen wir diese
Notwendigkeit und schreiben gleichzeitig kompakteren und intuitiveren code.


``` {r pipe}
data <- c(4.8, 15.16, 23.42)

data %>% 
  mean() %>% 
  round(digits = 1)
```

Die pipe nimmt das Ergebnis einer Zeile und gibt dieses an die nächste Zeile
weiter. Betrachten wir dieses Beispiel Schritt für Schritt. Die erste pipe gibt
das Objekt `data` an die nächste weiter. Hier wird die Funktion `mean()`
aufgerufen. Wie Sie sehen, dieses mal ohne Argumente zwischen den Klammern.
Trotzdem weiß R, dass `mean()` auf das Objekt `data` angewandt werden soll. Dies
funktioniert, da die pipe immer das Ergebnis der vorangegangenen Zeile als
erstes Argument der Funktion in der folgenden Zeile einfügt. So wird hier
`mean()` tatsächlich auf das Objekt `data` angewandt. Das Ergebnis, der
Mittelwert, wird durch die nächste pipe an die letzte Zeile weitergegeben und
eneut als erstes Argument eingesetzt, hier in die Funktion `round()`. Die
Rundung wird also auf den in der Zeile zuvor berechneten Mittelwert angewandt.

Dies funktioniert reibungslos mit allen Funktionen, die ein Datenobjekt auf das
sie angewandt werden sollen als erstes Argument nehmen, was sehr häufig der Fall
ist, aber nicht immer.

Der resultierende code ist intuitiver zu lesen und weniger schreibintensiv,
insbesondere wenn Sie sich früh angewöhnen die pipe mit der Tastenkombination
"Ctrl" + "Shift" + "M" einzufügen.

Das Endergebnis einer pipe Operation können wir ebenfalls einem Objekt zuweisen.
Die Objektzuweisung erfolt dabei allerdings bereits in der ersten Zeile.

``` {r pipe_2}
rounded_mean <- data %>% 
  mean() %>% 
  round(digits = 1)
```

Dies ist auf den ersten Blick etwas unintuitiv, da nicht `data` dem Objekt
`rounded_mean` zugewiesen wird, sondern das Ergebnis der letzten Zeile, also
der gerundetete Mittelwert.


## Hilfe?

### Hilfe!

Wir haben nun bereits einige R Funktionen kennengelernt und eine ungefähre Idee
davon, was diese machen. Wie bekommen wir aber weitere Informationen zu diesen
und neuen Funktionen, zu deren Funktionsweise, den zugelassenen Argumenten
oder den zurückgegebenen Ergebnissen?

Der einfachste Weg ist das Nutzen der eingebauten Hilfefunktionalitäten in R.
Dazu schreiben wir in der console einfach ein `?` vor den Namen einer Funktion
zu der wir Hilfe benötigen. Die zugehörige Hilfedatei öffnet sich dann im "Help"
Tab, rechts-unten. Versuchen wir dies für die Funktion `rnorm()`.

``` {r help, eval = FALSE}
?rnorm()
```

Die Hilfedatei gibt uns eine ganze reihe von Informationen. `rnorm()` ist Teil
einer Familie von Funktionen die sich auf die Normalverteilung beziehen. Dabei
ist die Funktionalität von `rnorm()` Zufallszahlen aus der Normalverteilung zu
generieren. Wir sehen auch, dass wir der Funktion 3 Argumente geben können. Die
Anzahl der zu erzeugenden Zufallszahlen `n` sowie Mittelwert `mean` und
Standardabweichung `sd` der zugrundeliegenden Normalverteilung. Dabei ist zu
erkennen, dass `mean` und `sd` die Standardwerte 0 beziehungsweise 1 haben.
Diese werden automatisch eingesetzt, wenn wir sie im Funktionsaufruf nicht durch
neue Werte ersetzen. `n` hat keinen Standardwert, hier müssen wir also einen
Wert angeben wenn wir die Funktion aufrufen. 

``` {r rnorm_1}
rnorm(n = 10)
```

So bekommen wir 10 Zufallswerte aus der Normalverteilung mit dem Mittelwert 0
und der Standardabweichung 1. Da es sich um Zufallszahlen handelt, wird Ihr
output von dem auf der website dargestellten abweichen.

Möchten wir Mittelwert und Standardabweichung anpassen, können wir die
entsprechenden Argumente nutzen um die Standardwerte durch andere zu ersetzen.

``` {r rnorm_2}
rnorm(n = 10, mean = 10, sd = 0.5)
```


Neben der Hilfefunktion, stellen viele packages sogenannte *vignettes* bereit,
Hilfedateien die in die Funktionalitäten des packages einführen. Schauen wir uns
dies für das **tibble** package an:

``` {r vignette_1, eval = FALSE}
vignette(package = "tibble")
```

Wir bekommen so eine Liste mit allen zu **tibble** verfügbaren vignettes zurück.
Einzelne dieser vignettes, rufen wir wie folgt auf:

``` {r vignette_2, eval = FALSE}
vignette("types")
```

Eine ausführlichere Dokumentation zu einem package, finden Sie außerdem meist
auf der dazugehörigen CRAN Seite, hier z.B. für **tibble**:
<https://cran.r-project.org/web/packages/tibble/index.html>{target="_blank"}.


### Empfohlene externe Resourcen

Es gibt eine Vielzahl von websites und Büchern zu R und RStudio. Einige davon
möchte ich hier vorstellen.

Die website von RStudio umfasst eine große Sammlung von Resourcen zu R und
der Arbeit mit spezfischen packages, darunter auch viele Webinars und Tutorial
Videos. Diese finden sie unter dem Menüpunkt "Resources" auf:
<https://www.rstudio.com/>{target="_blank"}

Die RStudio *cheatsheets* zu einigen der beliebteren packages bieten auf kleinem
Raum meist sehr gut zusammengefasste Informationen zu den Funktionen und der
Arbeitsweise eines packages. Die Nutzung der cheatsheets sei von mir dringend
empfohlen, und sie sind nicht nur beim Erlernen eines neuen packages sondern
auch als Erinnerungsstütze extrem hilfreich:
<https://www.rstudio.com/resources/cheatsheets/>{target="_blank"}

Eine weitere Sammlung von Tutorials zu unterschiedlichsten R Themen finden Sie
auf "R-bloggers":
<https://www.r-bloggers.com/>{target="_blank"}

Generell finden Sie im Internet eine kaum überschaubare Fülle von Informationen
und Resourcen zu R und spezifischen packages in Form von Videos, Blogs, 
digitalen Büchern und vor allem auch Foreneinträgen -- beispielsweise auf
<https://stackoverflow.com/>{target="_blank"}. So ist einer der wichtigsten
Skills den Sie entwickeln müssen das Formulieren von klaren und kurzen
Suchanfragen zu Ihrem spezifischen R Problem. In der Regel können Sie davon
ausgehen, dass die Antwort bereits im Netz existiert. Ihre Aufgabe ist es nun,
ihr Problem gut genug zu verstehen und eine entsprechende Suchanfrage zu
Schreiben um auf diese wertvollen Resourcen zugreifen zu können.

Das Internet gibt Ihnen ebenfalls Zugang zu einer Vielzahl umfassender
Einführungen in R sowie zu Online Versionen von R Büchern:

* *Intro to R for Social Scientists* von Jasper Tjaden.
Eine an Einsteiger gerichtete Einführung in R, die über das in diesem Seminar
gelernte R Basiswissen hinausgeht. Geschrieben als Begleitmaterial zu einem
Seminar an der Universität Potsdam im Sommersemester 2021.
<https://jaspertjaden.github.io/course-intro2r/>{target="_blank"}

* *R Cookbook, 2nd Edition* von J.D. Long & Paul Teetor.
Das Kochbuch besteht aus einer Reihe von Rezepten für spezifische Aufgaben die
Sie in R durchführen möchten. Dies ist weniger als durchgängig zu lesendes Buch
und mehr als Nachschlagewerk zu nutzen.
<https://rc2e.com/>{target="_blank"}

* *R for Data Science* von Hadley Wickham & Garrett Grolemund.
Eine Einführung in die Datenanalyse mit R, fokussiert auf die Arbeit mit dem
tidyverse. Geschrieben von zwei Zentralen Figuren des tidyverse und Mitarbeitern
bei RStudio.
<https://r4ds.had.co.nz/>{target="_blank"}
