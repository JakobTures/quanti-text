[["index.html", "Kurzeinführung zu R und der Datenanalyse mit dem tidyverse Einleitung Inhalt Konventionen Danksagung Colophon", " Kurzeinführung zu R und der Datenanalyse mit dem tidyverse Jakob Tures 2021-10-01 Einleitung Diese Kurzeinführung in R und in die Datenanaylse mit dem tidyverse package wurde als Begleitmaterial für das Seminar “Quantiative Datenanalyse mit R” an der Universität Potsdam im Wintersemester 2021/22 erstellt. Inhalt Kapitel 1 &amp; 2 führen in die Grundlagen von R und RStudio ein. R ist eine Programmiersprache die vor allem für statistische Analysen Anwendung findet. Die Grundfunktionen von R können durch das Einbinden von professionellen und nutzergeschriebenen packages erweitert werden. Diese Erweiterungen sind es, die R so flexibel machen und neben statistischen Analysen unter anderem auch das Schreiben von Websites direkt in R – so wie diese Website – und die Aufbereitung und Analyse von Textdaten ermöglichen. RStudio ist ein IDE – integrated development environment – für R und vereinfacht das Arbeiten mit der Sprache. Die ersten beiden Kapitel umfassen Informationen zur Installation beider Softwares, der Bedienung von RStudio sowie grundlegender R Befehlen. Während Kapitel 2 bereits die grundlegenden Prinzipien des tidyverse – einer populären Sammlung von R packages – erläutert, befassen sich Kapitel 3 &amp; 4 mit den zwei Bestandteilen der Sammlung die wir in der Datenanalyse am häufigsten verwenden werden. dplyr wird genutzt um Daten zu bereinigen, zu transformieren, neue Daten aus bestehenden zu erzeugen und zusammenfassende Statistiken zu berechnen. gplot2 gibt uns einen umfassenden Werzeugkasten zur graphischen Analyse an die Hand. Wir betrachten dessen grundlegende Syntax, einige häufig genutzte Diagrammtypen sowie Optionen die erstellten Plots ansprechend und aussagekräftig zu gestalten. Konventionen Die R Welt ist eine englischssprachige Welt. Die Namen von packages und Funktionen sind meist mehr oder weniger sprechend und stets Englisch. Auch sind die meisten Begriffe die sich auf R und RStudio beziehen englischsprachig. Sinnvolle Übersetzungen existieren meist nicht. Auch wäre es nicht zielführend diese Begriffe selbst zu übersetzen da dies nur unnötig verwirren würde. Einer der wichtigsten Skills die Sie im Umgang mit einer Sprache wie R entwickeln müssen, ist das gezielte Suchen nach Problemen beziehungsweisen deren Lösungen in Büchern und vor allem auch im Internet. Dazu benötigen Sie das englischsprachige Fachvokabular. Aus diesem Grund wurden englischsprachigen Fachbegriffe eingebunden ohne sie zu übersetzen. Die Namen von R packages werden fett geschrieben. Da R case sensitive ist, also Groß- und Kleinschreibung nicht beliebig austauschbar ist, werden die Namen der packages exakt so geschrieben wie sie benannt sind, auch wenn sie am Satzbeginn stehen. Ein Beispiel ist: tidytext Alle Codebeispiele sind in code font gesetzt. Teilweise im Text: print(\"Hello World\"), teilweise als code block: print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; Der output des R codes wird direkt innerhalb des code blocks hinter ## gedruckt. Ich empfehle dringend den Inhalt der code blocks selbst in RStudio laufen zu lassen und den code dabei auch selbst zu tippen statt ihn zu kopieren. Um eine Sprache wir R zu erlernen, muss man sie regelmäßig selbst schreiben. Nur so können die Namen häufig genutzter Funktionen sowie die R syntax in Ihr “muscle memory” übergehen. Danksagung Besonderer Dank gilt Lukas Höttges für die Unterstützung bei der Erstellung dieser Website und der Durchführung des korrespondierenden Seminars an der Universität Potsdam im Wintersemester 2021/22. Gleichermaßen danke ich den aktuellen und ehemaligen Teammitgliedern des Lehrstuhls für Methoden der empirischen Sozialforschung an der Universität Potsdam für ihr wertvolles Feedback zu technischen und inhaltlichen Fragen in diversen Kaffeepausen und Zoom-Gesprächen. Dank gilt auch den Erstellern der genutzten R packages, insbesondere bookdown und tidyverse, sowie der gesamten R community. Colophon Bei der Gestaltung dieser Website sowie der vorgestellten code Beispiele kam Folgendes zum Einsatz: sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.1 (2021-08-10) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Europe/Berlin ## date 2021-09-13 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.1.1) ## backports 1.2.1 2020-12-09 [1] CRAN (R 4.1.1) ## bookdown * 0.23 2021-08-13 [1] CRAN (R 4.1.1) ## broom 0.7.9 2021-07-27 [1] CRAN (R 4.1.1) ## bslib 0.2.5.1 2021-05-18 [1] CRAN (R 4.1.1) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.1.1) ## cli 3.0.1 2021-07-17 [1] CRAN (R 4.1.1) ## codetools 0.2-18 2020-11-04 [4] CRAN (R 4.0.3) ## colorspace 2.0-2 2021-06-24 [1] CRAN (R 4.1.1) ## crayon 1.4.1 2021-02-08 [1] CRAN (R 4.1.1) ## DBI 1.1.1 2021-01-15 [1] CRAN (R 4.1.1) ## dbplyr 2.1.1 2021-04-06 [1] CRAN (R 4.1.1) ## digest 0.6.27 2020-10-24 [1] CRAN (R 4.1.1) ## dplyr * 1.0.7 2021-06-18 [1] CRAN (R 4.1.1) ## ellipsis 0.3.2 2021-04-29 [1] CRAN (R 4.1.1) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.1.1) ## fansi 0.5.0 2021-05-25 [1] CRAN (R 4.1.1) ## fastmap 1.1.0 2021-01-25 [1] CRAN (R 4.1.1) ## fastmatch 1.1-3 2021-07-23 [1] CRAN (R 4.1.1) ## forcats * 0.5.1 2021-01-27 [1] CRAN (R 4.1.1) ## fs 1.5.0 2020-07-31 [1] CRAN (R 4.1.1) ## generics 0.1.0 2020-10-31 [1] CRAN (R 4.1.1) ## ggplot2 * 3.3.5 2021-06-25 [1] CRAN (R 4.1.1) ## glue 1.4.2 2020-08-27 [1] CRAN (R 4.1.1) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.1.1) ## haven 2.4.3 2021-08-04 [1] CRAN (R 4.1.1) ## hms 1.1.0 2021-05-17 [1] CRAN (R 4.1.1) ## htmltools 0.5.2 2021-08-25 [1] CRAN (R 4.1.1) ## httr 1.4.2 2020-07-20 [1] CRAN (R 4.1.1) ## janeaustenr 0.1.5 2017-06-10 [1] CRAN (R 4.1.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.1.1) ## jsonlite 1.7.2 2020-12-09 [1] CRAN (R 4.1.1) ## knitr * 1.33 2021-04-24 [1] CRAN (R 4.1.1) ## lattice 0.20-44 2021-05-02 [4] CRAN (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.1.1) ## lubridate 1.7.10 2021-02-26 [1] CRAN (R 4.1.1) ## magrittr 2.0.1 2020-11-17 [1] CRAN (R 4.1.1) ## Matrix 1.3-4 2021-06-01 [4] CRAN (R 4.1.0) ## modelr 0.1.8 2020-05-19 [1] CRAN (R 4.1.1) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.1.1) ## pillar 1.6.2 2021-07-29 [1] CRAN (R 4.1.1) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.1.1) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.1.1) ## quanteda * 3.1.0 2021-08-17 [1] CRAN (R 4.1.1) ## R6 2.5.1 2021-08-19 [1] CRAN (R 4.1.1) ## Rcpp 1.0.7 2021-07-07 [1] CRAN (R 4.1.1) ## RcppParallel 5.1.4 2021-05-04 [1] CRAN (R 4.1.1) ## readr * 2.0.1 2021-08-10 [1] CRAN (R 4.1.1) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.1.1) ## reprex 2.0.1 2021-08-05 [1] CRAN (R 4.1.1) ## rlang 0.4.11 2021-04-30 [1] CRAN (R 4.1.1) ## rmarkdown 2.10 2021-08-06 [1] CRAN (R 4.1.1) ## rstudioapi 0.13 2020-11-12 [1] CRAN (R 4.1.1) ## rvest 1.0.1 2021-07-26 [1] CRAN (R 4.1.1) ## sass 0.4.0 2021-05-12 [1] CRAN (R 4.1.1) ## scales 1.1.1 2020-05-11 [1] CRAN (R 4.1.1) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.1.1) ## SnowballC 0.7.0 2020-04-01 [1] CRAN (R 4.1.1) ## stopwords 2.2 2021-02-10 [1] CRAN (R 4.1.1) ## stringi 1.7.4 2021-08-25 [1] CRAN (R 4.1.1) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.1.1) ## tibble * 3.1.4 2021-08-25 [1] CRAN (R 4.1.1) ## tidyr * 1.1.3 2021-03-03 [1] CRAN (R 4.1.1) ## tidyselect 1.1.1 2021-04-30 [1] CRAN (R 4.1.1) ## tidytext * 0.3.1 2021-04-10 [1] CRAN (R 4.1.1) ## tidyverse * 1.3.1 2021-04-15 [1] CRAN (R 4.1.1) ## tokenizers 0.2.1 2018-03-29 [1] CRAN (R 4.1.1) ## tzdb 0.1.2 2021-07-20 [1] CRAN (R 4.1.1) ## utf8 1.2.2 2021-07-24 [1] CRAN (R 4.1.1) ## vctrs 0.3.8 2021-04-29 [1] CRAN (R 4.1.1) ## withr 2.4.2 2021-04-18 [1] CRAN (R 4.1.1) ## xfun 0.25 2021-08-06 [1] CRAN (R 4.1.1) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.1.1) ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.1.1) ## ## [1] /home/jakobtures/R/x86_64-pc-linux-gnu-library/4.1 ## [2] /usr/local/lib/R/site-library ## [3] /usr/lib/R/site-library ## [4] /usr/lib/R/library "],["R1.html", "1 R Basics 1.1 Installation 1.2 Erste Schritte 1.3 Objekte 1.4 Vektoren 1.5 Weitere Datentypen 1.6 R Packages 1.7 Funktionen", " 1 R Basics 1.1 Installation In diesem Kurs werden wir mit der Sprache R in Kombination mit der Entwicklungsumgebung RStudio arbeiten. Bevor wir mit der Einführung in die grundlegende Bedienung beginnen, zunächst einige Worte zur Installation der kostenlos zugänglichen Software. 1.1.1 R R ist eine Programmiersprache, die vor allem für statistische Analysen angewandt wird. Generelle Informationen zu R und die ausführliche Dokumentation finden sie unter: https://www.r-project.org/. Die aktuellste Version von R für alle gängigen Betriebssysteme findet sich stets im CRAN, dem Comprehensive R Archive Network unter: https://cran.r-project.org/. Die Links zu den Installationsdateien finden sich im oberen Bereich der Website. Falls Sie Windows nutzen, wählen Sie bitte die “base” Version. Im Falle von MacOS, hängt die Wahl des Installers von der Version Ihres Betriebssystems ab. In beiden Fällen führen Sie bitte die passende Datei aus und Installieren Sie R in ein Verzeichnis Ihrer Wahl. Für Linux Systeme stellt CRAN Installationsanweisungen für einige der populären Distribution bereit. Die Code Beispiele auf dieser Website wurden mit der R Version 4.1.1 “Kick Things” erstellt und getestet. 1.1.2 RStudio R kann nun bereits ausgeführt werden, erlaubt aber nur die Nutzung einer einfachen Konsole. Um die Arbeit mit R angenehmer zu gestalten, empfiehlt sich dringend die zusätzliche Installation einer IDE – Integrated Development Environment – also einer graphischen Benutzeroberfläche. Die populärste IDE ist RStudio, zu finden unter: https://www.rstudio.com/. Unter “Download” wählen Sie bitte die kostenlose Version von “RStudio Desktop” und den passenden Installer für Ihr Betriebssystem. Installieren Sie bitte zuerst R und erst danach RStudio. Starten brauchen Sie dann in Zukunft nur noch RStudio. 1.2 Erste Schritte 1.2.1 Übersicht RStudio Das RStudio Interface besteht aus vier Unterbereichen. Links-unten finden Sie die “Console” sowie weitere Tabs, die Sie zu Beginn selten bis nie brauchen werden. Die Konsole kann genutzt werden, um R code einzugeben und auszuführen, mehr dazu in Kürze. Links-oben werden geöffnete R scripts angezeigt. Aktuell haben Sie noch kein script geöffnet, ab Kapitel 2 wird dort aber der überwiegende Teil unserer Arbeit stattfinden. Rechts-oben finden sich mehrere Tabs, von denen für uns vor allem das “Environment” Tab von Interesse ist. Hier werden alle Objekte gelistet die Sie in ihrem code erstellen. Auch hierzu in Kürze mehr. Rechts-unten finden Sie erneute eine Anzahl Tabs. “Files” zeigt uns die Dateistruktur unseres Rechners, “Plots” den graphischen output (siehe Kapitel 3) und “Help” die Hilfedateien zu Funktionen und packages (mehr in Kapitel 2). 1.2.2 Hello World! Nun können wir endlich damit beginnen unseren ersten R Befehl auszuführen. In diesem Kapitel werden wir Kommandos noch ausschließlich in der Konsole schreiben. In der untersten Zeile der Konsole sehen Sie ein &gt; Symbol. Hinter dieser Eingabeaufforderung können wir unsere Befehle schreiben und mit “Enter” ausführen. Versuchen Sie des mit folgender Zeile: print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; Sie haben gerade ihren ersten R Befehl ausgeführt, Ihren ersten Output erhalten und gleichzeitig auch Ihre erste Funktion genutzt. Mehr zu Funktionen folgt am Ende dieses Kapitels, fürs Erste genügt es aber zu wissen, dass print() alles innerhalb der Klammern als Output druckt. Der Output selbst beginnt mit [1], was anzeigt, dass dies das erste und hier das einzige Element des Outputs ist. Bitte beachten Sie, dass R die auf dieser Website vor dem Output dargestellten ## nicht abdruckt. 1.2.3 Rechnen mit R R versteht die arithmethischen Operatoren + - * /. Sie können R also auch als übergroßen Taschenrechner nutzen. Für fortgeschrittenere Rechenoperationen steht eine Vielzahl von Funktionen zur Verfügung. Beispielsweise gibt Ihnen sqrt() die Quadratwurzel der von den Klammern umfassten Zahl als Output zurück. Oben mussten wir den Text \"Hello World!\" in Anführungszeichen einfassen. Zahlen müssen hingegen ohne Anführungszeichen geschrieben werden. Potenzen bekommen wir mit der Notation x^y. Im folgenden Codeblock finden Sie einige Beispiele, die Sie Zeile für Zeile in die console tippen und mit “Enter” ausführen können: 17 + 25 ## [1] 42 99 - 57 ## [1] 42 4 * 10.5 ## [1] 42 84 / 2 ## [1] 42 sqrt(1764) ## [1] 42 6.480741 ^ 2 ## [1] 42 1.2.4 Vergleichsoperatoren Vergleichsoperatoren können genutzt werden um zwei Werte miteinander zu vergleichen und das Testergebnis als TRUE oder FALSE Output zu erhalten. Um zu überprüfen, ob zwei Werte gleich sind, schreiben wir ==. Dabei ist zu beachten, dass ein Vergleich zweier Werte stets zwei Gleichheitszeichen voraussetzt. = hat eine andere Bedeutung! Um zu testen ob zwei Werte nicht gleich sind, können wir != nutzen, wobei das ! generell für nicht steht. 42 == 42 ## [1] TRUE 42 != 42 ## [1] FALSE Weitere mögliche Vergleiche sind kleiner &lt;, kleiner gleich &lt;=, größer &gt; und größer gleich &gt;=. 10 &lt; 42 ## [1] TRUE 42 &lt;= 42 ## [1] TRUE 10 &gt; 42 ## [1] FALSE 90 &gt;= 42 ## [1] TRUE 1.3 Objekte In R können wir Daten und Ergebnisse unserer Analysen in Objekten speichern. So bleiben diese im Arbeitsspeicher erhalten und können später erneut aufgerufen und weiterverwendet werden. Ein Objekt ist dabei ein frei gewählter Name dem wir Daten zuweisen. Namen müssen dabei mit einem Buchstaben beginnen und sollten nur weitere Buchstaben, Ziffern oder _ beinhalten. Verbreitete Konventionen für längere Objektnamen sind snake case – the_answer – und camel case – theAnswer. Dies ist letztlich Geschmackssache, es empfielt sich aber eine einheitliche Schreibweise sowie kurze aber klar verständliche Namen zu verwenden. Daten weisen wir einem Objekt mit dem assignment operator &lt;- zu. the_answer &lt;- 42 Um sich Fingerakrobatik zu ersparen, ist es sinnvoll sich frühzeitig die Tastenkombination “Alt” + “-” anzugewöhnen, die &lt;- an der aktuellen Cursor Position einfügt. Die so in einem Objekt gespeicherten Daten können wir aufrufen, indem wir den Objektnamen als Befehl schreiben. the_answer ## [1] 42 Wir können Werte in Objekten auch direkt in Berechnungen oder in Funktionen verwenden. Beachten Sie dabei, dass die Daten eines Objekts überschrieben werden, wenn wir diesem neue Daten zuweisen. the_answer &lt;- the_answer / 2 the_answer ## [1] 21 a &lt;- 17 b &lt;- 4 the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 So erstellte Objekte werden in dem “Environment” Tab (rechts-oben) gelistet. Möchten wir erstellte Objekte entfernen, können wir dazu die rm() Funktion nutzen. Dies ist zwar in der Regel nicht notwendig, kann aber hilfreich sein um versehentlich oder nur zum Test erstellte Objekte zu löschen und so den Tab etwas aufzuräumen. rm(the_answer) 1.4 Vektoren Als wir weiter oben eine Zahl einem Objekt zugewiesen haben, haben wir ohne es zu wissen bereits unseren ersten Vektor erstellt. Vektoren sind eindimensionale Datenstrukturen, die mehrere Elemente enthalten können. Die Länge eines Vektors bestimmt sich dabei anhand der Anzahl seiner Elemente. So erstellt auch the_answer &lt;- 42 einen Vektor, jedoch einen Vektor der Länge 1. Möchten wir einen Vektor mit mehreren Elementen erstellen, nutzen wir dazu die Funktion c(), wobei “c” für “combine” steht. So werden alle durch Kommata getrennten Werte innerhalb der Klammern zu einem Vektor kombiniert. v &lt;- c(7, 8, 9, 10) v ## [1] 7 8 9 10 1.4.1 Subsetting Möchten wir bestimme Elemente eines Vektors abrufen, nutzen wir subsetting. Dazu schreiben wir die Position des gewünschten Elements innerhalb des Vektors als Zahl in [] direkt nach dem Objektnamen. Um beispielsweise das erste oder das dritte Element unseres Vektors abzurufen: v[1] ## [1] 7 v[3] ## [1] 9 Mehrere Elemente gleichzeitig rufen wir ab indem wir mehrere Positionen mit c() kombinieren oder wir definieren mit : eine Spannweite von Positionen. v[c(1, 3)] ## [1] 7 9 v[2:4] ## [1] 8 9 10 1.4.2 Typen von Vektoren Betrachten wir den Vektor v im Environment, fällt auf, dass RStudio num [1:4] vor den gespeicherten Werten abduckt. Dies drückt zum einen aus, dass der Vektor die Länge 4 hat, zum anderen zeigt es den Typ des Vektors an. Hier handelt es sich um einen numerischen Vektor – numeric, ausgedrückt durch “num” – also einen Vektor der Zahlen enthält. Um Imformationen zu Typ, Länge und Inhalt von Objekten zu erhalten können wir auch die Funktion str() – structure – nutzen. Dies ist vor allem bei komplexeren Objekten wie Listen oder Dataframes (mehr dazu später) hilfreich, um einen ersten Überblick zu erhalten, ohne das komplette Objekt abzudrucken. str(v) ## num [1:4] 7 8 9 10 R kennt noch weitere Typen von Vektoren, wobei für uns vor allem die Typen logical und character von Bedeutung sind. Logische Vektoren können nur die Werte TRUE und FALSE enthalten. Diese entstehen beispielsweise, wenn wir Vergleichsoperatoren für einen Test nutzen. x &lt;- c(1, 7, 3, 5) x &gt;= 5 ## [1] FALSE TRUE FALSE TRUE Wir können logische Vektoren aber auch selbst erstellen. z &lt;- c(TRUE, FALSE, TRUE) z ## [1] TRUE FALSE TRUE Character Vektoren beinhalten Zeichenfolgen, sogenannte strings. Strings müssen stets von Anführungszeichen umschlossen sein. char_v &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;character&quot;, &quot;vector!&quot;) char_v ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;character&quot; &quot;vector!&quot; Auch Character Vektoren können miteinander verglichen werden. &quot;same&quot; == &quot;same&quot; ## [1] TRUE &quot;same&quot; == &quot;not the same&quot; ## [1] FALSE &quot;same&quot; != &quot;not the same&quot; ## [1] TRUE Da wir mit Character Vektoren natürlich nicht rechnen können, kann es zu Problemen kommen, wenn wir Zahlenwerte – beispielsweise als Strings aus einem Text ausgelesen – als Character Vektor gespeichert haben. a &lt;- c(1, 2, 3) b &lt;- c(&quot;7&quot;, &quot;8&quot;, &quot;9&quot;) str(a) ## num [1:3] 1 2 3 str(b) ## chr [1:3] &quot;7&quot; &quot;8&quot; &quot;9&quot; a + b ## Error in a + b: non-numeric argument to binary operator Wir können R aber anweisen einen Character Vektor in einen numerischen Vektor umzuwandeln. a + as.numeric(b) ## [1] 8 10 12 Alle Typen von Vektoren können neben ihren nativen Inhalten auch NA enthalten, die Repräsentation von fehlenden Werten in R. c &lt;- c(1, 2, NA, 4) c ## [1] 1 2 NA 4 1.5 Weitere Datentypen 1.5.1 Dataframes Dataframes sind zweidimensionale Datenobjekte aus Spalten und Zeilen, also das was wir uns im Allgemeinen unter einer Tabelle vorstellen. Spalten enthalten benannte Variablen, Zeilen enthalten Beobachtungen. Um einen Dataframe zu erstellen nutzen wir die Funktion data.frame() und definieren innerhalb der Klammern benannte Spalten und ihre Inhalte, getrennt durch Kommata. df &lt;- data.frame(Name = c(&quot;Peter&quot;, &quot;Mary&quot;), Alter = c(42, 24), Weiblich = c(FALSE, TRUE)) df ## Name Alter Weiblich ## 1 Peter 42 FALSE ## 2 Mary 24 TRUE R erkennt dabei automatisch, welche Datentypen die Spalten enthalten. str(df) ## &#39;data.frame&#39;: 2 obs. of 3 variables: ## $ Name : chr &quot;Peter&quot; &quot;Mary&quot; ## $ Alter : num 42 24 ## $ Weiblich: logi FALSE TRUE Wir können Dataframes auch aus zuvor definierte Vektoren zusammensetzen. name &lt;- c(&quot;Peter&quot;, &quot;Mary&quot;) age &lt;- c(42, 24) female &lt;- c(FALSE, TRUE) df_2 &lt;- data.frame(Name = name, Alter = age, Weiblich = female) df_2 ## Name Alter Weiblich ## 1 Peter 42 FALSE ## 2 Mary 24 TRUE Da Dataframes zweidimensional sind, müssen wir beim Subsetting auch eine Position für die Zeilen und Spalten angeben. Diese werden ebenfalls in [] nach dem Objektnamen eingefasst und sind durch ein Komma getrennt. Vor dem Komma steht die Position der Zeilen, nach dem Komma die Position der Spalten. Für Spalten können wir statt der Position auch den Namen der Spalte nutzen. df[1, 2] ## [1] 42 df[1, &quot;Alter&quot;] ## [1] 42 Extrahieren wir mehrere Zeilenelemente gleichzeitig, bekommen wir einen neuen Dataframe zurück. Um eine ganze Zeile zu extrahieren, können wir den Wert der Spaltenposition auch freilassen. Gleiches gilt für ganze Spalten, wobei wir beim Subsetting einer einzelnen Spalte einen Vektor als Output bekommen, bei mehreren erneut einen Dataframe. df[1, 2:3] ## Alter Weiblich ## 1 42 FALSE df[1, ] ## Name Alter Weiblich ## 1 Peter 42 FALSE df[, &quot;Alter&quot;] ## [1] 42 24 df[, c(&quot;Alter&quot;, &quot;Weiblich&quot;)] ## Alter Weiblich ## 1 42 FALSE ## 2 24 TRUE 1.5.2 Listen Vektoren und Spalten von Dataframes können immer nur Daten eines Typs enthalten. Mischen wir Datentypen, werden diese auf den kleinsten gemeinsamen Nenner gebracht. Logische Werte können auch numerisch abgebildet werden, da TRUE dem Wert 1 entspricht, FALSE dem Wert 0. In letzter Instanz können alle Datentypen als Character Vektoren gespeichert werden. log_vector &lt;- c(24, TRUE) str(log_vector) ## num [1:2] 24 1 char_vector &lt;- c(&quot;Mary&quot;, 24, TRUE) str(char_vector) ## chr [1:3] &quot;Mary&quot; &quot;24&quot; &quot;TRUE&quot; Möchten wir Datentypen mischen, können wir stattdessen Listen nutzen, welche unterschiedliche Datentypen enthalten können. l &lt;-list(&quot;Mary&quot;, 24, TRUE) str(l) ## List of 3 ## $ : chr &quot;Mary&quot; ## $ : num 24 ## $ : logi TRUE Um Listen wieder aufzulösen, nutzen wir unlist(). unlist(l) ## [1] &quot;Mary&quot; &quot;24&quot; &quot;TRUE&quot; Listen können sogar andere Listen enthalten und sind so das flexibelste Datenobjekt das R bereitstellt. Beim Subsetting von Listen ist darauf zu achten, dass [] immer auch eine Liste zurückgibt, selbst wenn diese nur noch ein Element enthält. Direkten Zugang zu Elementen erhalten wir mit [[]]. str(l[1]) ## List of 1 ## $ : chr &quot;Mary&quot; str(l[[1]]) ## chr &quot;Mary&quot; 1.6 R Packages Die R Welt ist offen und kollaborativ. Neben dem base R Package, das in der Grundinstallation bereits enthalten ist, steht eine stetig steigende Zahl von nutzergeschriebenen Packages zum Download zur Verfügung. Diese Packages haben stets einen thematischen Fokus – beispielsweise Datenbereinigung, graphische Analyse oder Textanalyse – und enthalten eine Reihe von Funktionen, die den Einsatzbereich von R über das hinaus erweitern, was von den Originalentwicklern geplant war, oder kompliziert gestaltete base R Ansätze durch neue anwenderfreundlichere Funktionen ersetzen. Packages, ihre Dokumentation und weitere Informationen werden ebenfalls auf CRAN gehostet. Hier haben Sie auch bereits die Installationsdateien für R heruntergeladen. Wenn Sie gleich ein Package direkt aus RStudio installieren, greift die Software auf CRAN zu, um die erforderlichen Dateien herunterzuladen. 1.6.1 Installieren und Laden Packages installieren wir mit der R Funktion install.packages(), mit dem Namen des packages in \"\" zwischen den Klammern der Funktion. Wir werden im Laufe des Seminars eine Reihe von Packages nutzen, darunter das tidyverse. Zur Installation des core tidyverse packages schreiben wir in der Konsole: install.packages(&quot;tidyverse&quot;) R wird während der Installation eine lange Reihe von Informationen ausgeben, von denen uns – solange alles gut geht – nur das DONE (tidyverse) interessieren muss. Nach erfolgreicher Installation können wir das Paket laden. Ein Package laden wir mit library() mit dem Namen des Packages innerhalb der Klammern, hier ausnahmsweise ohne \"\". library(tidyverse) Manche Pakete, wie das tidyverse, geben uns auch beim Laden eine Reihe von Informationen, die wir gleich noch genauer betrachten werden. Andere Pakete laden aber auch still, ohne Informationen in die Konsole zu schreiben. Sollte beim Laden eines packages ein Problem auftauchen, wird R dies rückmelden. 1.7 Funktionen Bis zu diesem Punkt haben wir bereits eine Reihe von Funktionen genutzt, ohne eigentlich zu wissen, was Funktionen sind. Die in base R und den diversen Packages enthaltenen Funktionen bieten einen einfachen Zugang zu komplexeren im Hintergrund ablaufenden Operationen. Statt beispielsweise eine komplizierte Datenanalysetechnik selbst zu implementieren, also jeden Rechenschritt Zeile für Zeile selbst zu schreiben, installieren wir ein Package mit einer passenden Funktion und sparen eventuell mehrere hundert Zeilen Code ein. Außerdem sind die Rechenoperationen in den Packages meist sehr viel effizienter geschrieben als Code, den wir als Laien schreiben würden. Um eine Funktion aufzurufen, schreiben wir deren Namen gefolgt von Klammern. Innerhalb der Klammern geben wir ein oder mehrere Argumente an die Funktion weiter. In vielen Fällen wird als erstes oder eniziges Argument ein Datenobjekt – oder rohe Daten – angegeben, auf das die Funktion angewandt werden soll. So “druckt” beispielsweise die base R Funktion print() die angegebenen Daten in die Konsole, wie bereits bei print(\"Hello World!\") gesehen. Weitere Beispiele für Funktionen sind einige der in base R enthaltenen Möglichkeiten, statistische Maßzahlen zu berechnen. Legen wir zunächst einen numerischen Vektor mit einigen Beispieldaten an: data &lt;- c(4, 8, 15, 16, 23, 42) Unser Interesse sei es, das arithmetische Mittel, den Median sowie die Standardabweichung der Daten zu berechnen. Dazu können wir die Funktionen mean(), median() und sd() aus base R nutzen. Allen drei Funktionen geben wir als einziges Argument die zuvor in einem Objekt gespeicherten Daten weiter. Weitere Argumente sind zwar möglich, für dieses Beispiel aber nicht notwendig. mean(data) ## [1] 18 median(data) ## [1] 15.5 sd(data) ## [1] 13.49074 Funktionen erlauben häufig mehrere Argumente, von denen einige optional sein können und es beispielsweise ermöglichen bestimmte Optionen einer Funktion zu verändern. Dies wird uns im weiteren Verlauf regelmäßig begegenen. 1.7.1 Namesspaces Betrachten wir nochmals den Output nach dem Laden von tidyverse weiter oben. R gibt uns neben Namen und Versionen der geladenen packages – das core tidyverse Package, welches wir geladen haben ist eigentlich eine Sammlung von Packages – auch die Information über zwei Konflikte aus. Konflikte entstehen, wenn zwei geladene packages Funktionen mit den selben Namen enthalten. Die Funktion aus dem später geladenen package überschreibt dabei die zuvor geladene Funktion. Hier überschreibt das tidyverse package dplyr die Funktionen filter() und lag() aus dem base R package stats. Ohne dplyr beziehungsweise tidyverse zu laden wäre beim aufruf von filter() die Funktion aus dem stats package genutzt worden. Nun wird die gleichnamige Funktion aus dplyr angewandt. Möchten wir zwar dplyr laden, aber die Funktion filter() aus stats nutzen, können wir den Namespace der Funktion explizit angeben. Der Namespace gibt R an, in welchem Package es nach der Funktion suchen soll. Geben wir nur den Funktionsnamen an, sucht R in den Funktionen die aktuell geladen sind. Da filter() aus dplyr die Funktion aus stats überschrieben hat, würde erstere angewandt. Deklarieren wir den Namespace, können wir R genau angeben, in welchem geladenen oder ungeladenen package die Funktion zu finden ist. Dazu nutzen wir die Notation namespace::function. Um also filter() aus stats zu nutzen, schreiben wir: stats::filter(). "],["R2.html", "2 RStudio &amp; das tidyverse 2.1 RStudio workflow 2.2 tidyverse 2.3 Hilfe?", " 2 RStudio &amp; das tidyverse 2.1 RStudio workflow Im vorangegangenen Kapitel haben wir unsere Befehle direkt in die R Konsole eingegeben, mit “Enter” bestätigt und unseren Output zurückbekommen. Dies ist allerdings nicht die standardmäßige Anwendung von R (oder anderen Programmiersprachen). Das Hauptproblem besteht hierbei darin, dass unser Code nach dem Ausführen nicht erhalten bleibt. Wir können zwar durch die Konsole scrollen, um nachzuvollziehen, welche Befehle wir genutzt haben, dies ist uns aber spätestens nach dem Schließen von RStudio nicht mehr zugänglich. In der Realität werden Sie aber häufig längere Zeiträume an einem Projekt arbeiten und möchten eventuell ihren Code mit Kommiliton:innen, Kolleg:innen oder der R Community teilen. Je komplexer unser Code wird, desto mehr Fehler werden wir auch machen. Ein früher Fehler in der Konsole, der erst spät auffällt, kann bedeuten, dass der Großteil unserer Arbeit wiederholt werden müsste. Deswegen arbeitet man statt der Konsole mit sogenannten Scripts. 2.1.1 R Scripts Ein R Script ist eine Datei, in der wir unsere Befehle niederschreiben und so für die spätere Weiterarbeit und Weitergabe dokumentieren. Um ein neues R Script zu erstellen, klicken Sie auf “File” &gt; “New File” &gt; “R Script”, oder nutzen Sie die praktische Tastenkombination “CTRL” + “Shift” + “N”. So wird ein leeres und unbenanntes neues Script erstellt. Als erste Übung können wir ein Stück Code aus dem vorangegangenen Kapitel statt in die Konsole in unser R Script eingeben. a &lt;- 17 b &lt;- 4 the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 Zur Erinnerung: wir erstellen zwei numerische Objekte a und b, weisen das Ergebnis einer Berechnung mit diesen zwei Objekten einem neuem Objekt the_answer zu und lassen uns dieses Objekt, also das Ergebnis der Berechnung, ausgeben. Statt die Befehle Zeile für Zeile in die Konsole einzugeben und jede Zeile direkt auszuführen, schreiben wir zunächst den kompletten Codeblock in unser neues Script. Danach können wir unser komplettes Script durch einen Klick auf “Source” in der toolbar des Script Fensters ausführen. Ich empfehle Ihnen stattdessen aber, Scripts stets Befehl für Befehl auszuführen. So haben Sie die volle Kontrolle über den Prozess, sehen sofort das Ergebnis (oder den Fehler) jedes einzelnen Befehls und können die Ausführung an jeder beliebigen Stelle pausieren, zum Beispiel um den Code besser nachzuvollziehen, Fehler zu erkennen oder Veränderungen vorzunehmen. Umsetzen können Sie dies mit einem Klick auf “Run” in der Toolbar des Scripttabs oder noch einfacher durch das Drücken von “CTRL” + “Enter”. In beiden Fällen wird die Zeile, in der sich aktuell Ihr Cursor befindet ausgeführt. Dieser springt daraufhin automatisch in die nächste Zeile, sodass Sie auch Befehl für Befehl schnell ihr ganzes Script ausführen können, dabei aber die volle Kontrolle behalten. Was für Sie praktikabler ist, müssen Sie selbst entscheiden und kann auch von der Situation abhängen. Bedenken Sie aber immer, dass R zu jedem Zeitpunkt davon ausgeht, dass Sie wissen was Sie tun. Es wird keine Warnmeldungen geben, wenn Sie etwas überschreiben das Sie eigentlich nicht überschreiben wollten. Sie sollten ihr Script regelmäßig abspeichern. Nicht nur dann, wenn Sie eine Arbeitssession beenden, sondern regelmäßig. Dies können sie über “File” &gt; “Save” erreichen oder durch die Tastenkombination “CTRL” + “S”. Sie können den Namen des Scripts frei wählen, die Endung muss jedoch immer “.R” sein. Ein Problem, das Ihnen früher oder später begegnen wird, ist, dass Sie versehentlich versuchen werden inkompletten Code aus einem Script auszuführen. Der Grund ist sehr häufig eine fehlende schließende Klammer, wie in print(\"Hello World\". R kann den Code nicht interpretieren und geht aufgrund der fehlenden Klammer davon aus, dass der Code noch weitergehen soll. R übernimmt dann den inkompletten Code in die Konsole, führt ihn aber nicht aus, sondern beginnt eine neue Zeile mit einem +. Dies bedeutet, dass wir hinter dem + den Code fortsetzen können. In der Regel ist es dann am sinnvollsten, die Ausführung des Codes abzubrechen, indem sie in die Konsole klicken und danach “Esc” drücken. Dann können wir den Code in unserem Script korrigieren und erenut ausführen. 2.1.2 Projekte Häufig werden unsere R Vorhaben aus mehreren Dateien – wie Scripts, Datensätzen oder ausgegebenen Graphiken – bestehen. Es macht dann häufig Sinn, diese Dateien an einem gemeinsamen Ort abzuspeichern. Dies könnten wir natürlich “per Hand” managen, RStudio’s Projektfunktion kann hier aber sehr hilfreich sein. Durch Klicken auf “File” &gt; “New Project”, erstellen wir ein neues Projekt. Haben wir bereits einen Ordner für das Projekt angelegt, können wir auf “Existing Directory” klicken, den Ordner auswählen und die Erstellung mit “Create Project” abschließen. Oder wir erstellen mit “New Directory” &gt; “New Project” einen neuen Ordner für das Projekt direkt aus RStudio. RStudio wird nun alle aktuell geöffneten Dateien schließen und in das neu erstellte Projekt wechseln. Der Name des gewählten oder erstellten Ordners ist auch gleichzeitig der Name des Projekts, angezeigt in der Titelleiste von RStudio. Der “Files” tab (rechts-unten) zeigt nun auch den Inhalt des Projektordners. Dies ist ihr aktuelles working directory, mehr dazu gleich. Sie können nun Dateien erstellen und bearbeiten und speichern diese ganz normal ab. Das Projekt selbst muss nie gespeichert werden. Möchten Sie in einer späteren R Session ihre Arbeit an dem Projekt fortsetzen, klicken Sie auf “File” &gt; “Open Project”. Das Projekt wird geöffnet, alle Dateien die Sie bei der letzten Session geöffnet hatten sind erneut geöffnet und Sie befinden sich auch wieder im working directory des Projekts. Projekte sind eine einfache und praktische Methode, um Ihre Arbeiten zu organisieren und aufgeräumt zu halten. An dieser Stelle wäre es eventuell sinnnvoll, wenn Sie ein Projekt zu diesem Seminar erstellen. Sie könnten dann Scripts für jedes Kapitel anlegen oder weitere Unterordner für Übungen usw. einrichten. Ob dies für Sie eine sinnvolle Arbeitsweise ist, bleibt aber Ihnen überlassen. Wir sollten nun noch kurz über das working directory sprechen. Dieses wird zum Beispiel dann relevant, wenn Sie versuchen eine Datei direkt aus einem Script heraus zu öffnen oder zu speichern. Geben Sie dabei keinen kompletten absoluten Pfad an, geht R immer davon aus, dass Sie sich auf das working directory beziehen. Arbeiten Sie in einem Projekt, ist das working directory automatisch das Hauptverzeichnis des Projekts. Mit getwd() gibt Ihnen R ihr aktuelles Arbeitsverzeichnis zurück. Ihr Arbeitsverzeichnis können Sie über “Session” &gt; “Set Working Directory” &gt; “Choose Directory…” oder mit der Funktion setwd() ändern, wobei der Pfad mit \"\" eingefasst zwischen die Klammern geschrieben wird. 2.1.3 Kommentare Einer der wichtigsten Skills beim Schreiben von Code, ist das Kommentieren des Selbigen. Kommentare können wir direkt in Scripts schreiben, diese werden jedoch nicht ausgeführt, sondern dienen der Erläuterung und Strukturierung des Codes. Einen Kommentar markieren wir mit einem oder mehreren #. Text der auf ein # folgt wird von R als Kommentar erkannt und entsprechend nicht ausgeführt. Wenn Sie über längere Zeit an einem Projekt arbeiten oder dieses nach längerer Zeit erneut öffnen, kann es für sie selbst manchmal schwierig sein nachzuvollziehen, was Sie mit ihrem Code erreichen wollten. Gut kommentierter Code erleichtert dies stark. Dies wird nochmals relevanter, wenn Sie ihren Code mit anderen Personen teilen. Für die meisten Probleme in R bestehen eine Vielzahl möglicher Ansätze. Gut kommentierter Code hilft Anderen zu verstehen, was ihr Ansatz ist. Hier können Sie die Zeit, die Sie in das Kommentieren investieren als Respekt gegenüber der Zeit verstehen, die Andere investieren um Ihren Code zu verstehen. Ihnen wird eventuell aufgefallen sein, dass der Output der Codeblöcke auf dieser website mit ## beginnt. Im Output Ihrer R Konsole fehlen diese. Beim Erstellen der Website mit dem package bookdown werden die Symbole automatisch im Output eingefügt, um das Kopieren und Einfügen der Code Blöcke in Ihre Scripts zu erleichtern. So wird der mit ## markierte Output von R als Kommentar verstanden und nicht als Befehl ausgeführt. Dies ist oft praktisch, trotzdem empfehle ich weiterhin, so viel wie möglich selbst zu Tippen und copy/paste nur spärlich zu verwenden. Hier ein Beispiel eines bereits bekannten Codeblocks, diesmal mit Kommentaren versehen: # assigning objects a &lt;- 17 b &lt;- 4 # calculating the answer the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 # but what is the question? Falls Sie setwd() in Ihrem Script verwenden, empfiehlt es sich, dies auszukommentieren, bevor sie das Script weitergeben. Andere Personen haben andere Ordnerstrukturen als Sie und können mit Ihrem individuellen setwd() nichts anfangen. Im besten Fall wird ihr setwd() nicht ausführbar sein, im schlechtesten bringen Sie die Ordnerstruktur einer anderen Person durcheinander. Ähnliches gilt für Befehle, die etwas auf die Festplatte speichern, beispielsweise Datensätze oder exportierte Graphiken. Die R community ist grundsätzlich sehr bereitwillig auch Anfängern mit Coding Problemen zu helfen. Wir sollten diese Bereitschaft damit würdigen gut kommentierten Code weiterzugeben und davon abzusehen, in die Dateistruktur anderer Personen einzugreifen. 2.1.4 Speichern Aus dem Blickwinkel reproduzierbarer Datenanalyse ist es aus meiner Sicht meist der beste Ansatz, ein Script zu erstellen in dem die rohen Daten eingelesen, bereinigt, transformiert sowie statistisch und graphisch analysiert werden. So ist es jeder Person mit Zugriff auf die Daten und ihr Script möglich, jeden ihrer Arbeitsschritte nachzuvollziehen und zu reproduzieren. Dies ist eine der Säulen transparenter wissenschaftlicher Praxis. Bei diesem Ansatz müssen wir also selten die Ergebnisse unserer Analysen als Datensatz abspeichern. Das Script – die “.R” Datei – ist ausreichend. Es gibt aber auch Situationen, in denen es sinnvoll sein kann, Ergebnisse abzuspeichern. Quantitative Textanalysen können bespielsweise sehr rechenintensiv sein. Bei der Anwendung fortgeschrittener Methoden im Machine Learning auf sehr große Datensätze, können schonmal mehrere Stunden bis Tage Rechenzeit anfallen. Auch wenn wir solche Zeitdmensionen in diesem Seminar nicht erreichen, kann es hilfreich sein auch die Ergebnisse einer Operation im niedrigen Minutenbereich abzuspeichern, um Rechenzeit bei regelmäßiger Arbeit mit den Ergebnissen zu sparen. Die einfachste Möglichkeit ist es, zum Speichern das native R Datenformat “.RData” zu nutzen. Erstellen wir einen kurzen Dataframe, um diesen gleich abzuspeichern: data &lt;- data.frame( name = c(&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;), age = c(42, 84, 24), size = c(1.68, 1.82, 1.74), retired = c(FALSE, TRUE, FALSE) ) Mit save() können wir “.RData” Dateien speichern. Dazu schreiben wir innerhalb der Klammern zunächst den Namen des Objekts – oder mehrerer Objekte mit c() zusammengefasst – gefolgt von einem , und dem Argument file = \"\". Innerhalb der \"\" legen wir einen Dateinamen mit einem optionalen Pfad fest. Eine Datei ohne angegebenen Pfad wird im aktuellen working directory gespeichert. save(data, file = &quot;peter_paul_mary.RData&quot;) Um die gespeicherten Daten wieder zu laden, nutzen wir die Funktion load() mit dem Namen beziehungsweise Pfad der Datei als einzigem Argument. load(&quot;peter_paul_mary.RData&quot;) So haben wir Daten in dem schnellen und gut komprimierten nativen “.RData” Format gespeichert. Der Nachteil ist, dass diese Daten auch nur in R genutzt werden können. Interessieren sie sich dafür, Daten in einem besser transportierbaren Format zu speichern, bietet sich “.csv” an. Mehr dazu in Kapitel 3.5 sowie hier: https://jakobtures.github.io/web-scraping/files.html 2.2 tidyverse Weiter oben haben wir das tidyverse Package installiert und geladen. Dieses wird uns durch das ganze Seminar begleiten. Das tiydverse ist eine beliebte Sammlung von R Packages, die einer gemeinsamen Philosophie der Funktionssyntax sowie der Datenstruktur folgen und dabei viele datenanalytische Arbeitsprozesse abdecken. Der Vorteil ist, dass Sie, sobald Sie die Grundlogik verstanden haben, sehr schnell auch weitere tidyverse Packages verstehen werden. Letztlich ist es Geschmackssache, aber aus meiner Sicht führt das Arbeiten mit dem tidyverse zu intuitiverem und flüßiger zu schreibendem R Code. Aktuell besteht das core tidyverse Package aus acht individuellen Packages. Diese werden alle automatisch geladen, wenn wir library(tidyverse) schreiben. Das core tidyverse deckt einen Großteil der besonders regelmäßig auftretenden datenanalytischen Funktionalitäten ab. Dazu gehören das Einlesen, Reinigen und Transformieren von Daten oder die graphische Analyse. Im weiteren werden wir viele Funktionen aus dem core tidyverse sehr regelmäßig nutzen. Nebem dem core tidyverse besteht eine wachsende Zahl zugehöriger Packages, welche nach den selben Grundsätzen funktionieren, dabei aber speziellere Aufgabenfelder abdecken. Auch diese wurden mit install.Packages(\"tidyverse\") bereits installiert, müssen aber explizit geladen werden. Darunter beispielsweise lubridate zum Umgang mit Datumsangaben und eine Reihe von Packages zum Einlesen bestimmter Datentypen. Eine volle Liste der tidyverse Packages finden Sie unter: https://www.tidyverse.org/Packages/ Für eine umfassendere Einführung in das tidyverse bietet sich das Buch “R for Data Science” von Wickham &amp; Grolemund an, welches auch Online zugänglich ist: https://r4ds.had.co.nz/ 2.2.1 tidy data Das tidyverse folgt einer geteilten Philosophie der Datenstruktur namens tidy data. Einfach ausgedrückt steht tidy data dafür, dass jede Variable eines Datensatz eine eigene Spalte in einer Tabelle bekommt und jede Beobachtung eine eigene Zeile. Die Werte zu den Kombinationen von Variablen und Beobachtungen stehen dann logisch folgend in den Zellen. Betrachten wir folgenden Dataframe, welcher bisherige (04.09.2021) Umfragewerte für die Wahl zum 20. Bundestag enthält. Die Daten stammen von: https://www.wahlrecht.de/umfragen/index.htm ## Institut CDU_CSU SPD GRÜNE FDP LINKE AfD Sonstige ## 1 Kantar 21 25 19 11 7 11 6 ## 2 Infratest 20 25 16 13 6 12 8 Diese Darstellungsform ist uns sofort intuitiv verständlich. So sehen Tabellen in Excel oder in Zeitungen aus und die Darstellung ist kompakt und übersichtlich. Aber ist Sie auch tidy? Dazu müssen wir uns Gedanken darüber machen, welche Variablen die Tabelle enthält. Die erste Spalte bildet die Variable “Institut” ab. Dies macht Sinn. Die restlichen 7 Spalten enthalten die Umfragewerte für die 6 aktuell im Bundestag vertretenen Parteien sowie “Sonstige”. Wir haben also eigentlich 2 Variablen: “Umfragewert” und “Partei”, welche aktuell in 7 Spalten dargestellt werden. Sie erinnern sich, jede Variable bekommt in einem tidy Datensatz eine Spalte. Zudem werden die Werte der Variable “Partei” auch gar nicht als Werte in der Tabelle sondern in den Spaltennamen abgebildet. Die Tabelle ist also eindeutig nicht tidy. Vergleichen Sie dies zu folgendem Dataframe: ## Institut Partei Umfragewert ## 1 Kantar CDU_CSU 21 ## 2 Kantar SPD 25 ## 3 Kantar GRÜNE 19 ## 4 Kantar FDP 11 ## 5 Kantar LINKE 7 ## 6 Kantar AfD 11 ## 7 Kantar Sonstige 6 ## 8 Infratest CDU_CSU 20 ## 9 Infratest SPD 25 ## 10 Infratest GRÜNE 16 ## 11 Infratest FDP 13 ## 12 Infratest LINKE 6 ## 13 Infratest AfD 12 ## 14 Infratest Sonstige 8 Diese Darstellung ist tidy. Wir haben 3 Variablen “Institut”, “Partei” und “Umfragewert” die jeweils in einer eigenen Spalte stehen. Beobachtungen sind nun nicht mehr das komplette Set von Umfragewerten eines Umfrageinstituts, sondern der Umfragewert einer Partei bei einem Insitut. Das Ergebnis ist eine Tabelle, die den Prinzipien der tidy data folgt, die uns auf den ersten Blick aber seltsam erscheint, da wir nicht daran gewohnt sind, Daten in dieser Form darzustellen. Wir sollten aber auch bedenken, dass es an dieser Stelle nicht das Ziel ist, eine schöne Tabelle für menschliche Leser zu präsentieren, sondern ein Datenobjekt zu konstruieren, welches uns die praktische und komfortabele Weiterarbeit mit den diversen tidyverse Packages ermöglicht. Mehr zu den angedeuteten Prinzipien der tidy data finden Sie im entsprechenden Kapitel von “R for Data Science” von Wickham &amp; Grolemund: https://r4ds.had.co.nz/tidy-data.html. 2.2.2 Tibbles Das tibble Package ist Teil des core tidyverse und bietet eine Alternative zur base R Darstellung von Tabellen als Dataframes. Dabei liegen viele der Unterschiede zwischen Tibbles und Dataframes eher im Detail. Für uns sind vor allem die Art wie Tibbles in die Konsole gedruckt werden und wie das subsetting funktioniert relevant. Mehr zu Beidem gleich. Eine ausführlichere Einführung finden Sie erneut in “R for Data Science”: https://r4ds.had.co.nz/tibbles.html Tibbles erstellen wir dabei auf die selbe Weise wie Dataframes, nutzen dazu aber die Funktion tibble(). Dazu müssen wir zunächst das tibble beziehungsweise das tidyverse Package, welches tibble enthält, laden. Das Laden von Packages sollte in den ersten Zeilen eines Scripts passieren. So werden alle notwendigen Packages zu Beginn eines Scripts geladen und andere Nutzer*innen sehen sofort welche Packages eventuell noch nachinstalliert werden müssen. Hier geben wir die Daten direkt bei der Erstellung der Tibble ein. Wie bei Dataframes können wir Tibbles aber auch aus zuvor definierten Vektoren zusammensetzen. library(tidyverse) tibble(numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE)) ## # A tibble: 3 × 3 ## numbers strings logicals ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 zero FALSE ## 2 1 one TRUE ## 3 2 two TRUE Bevor wir den Output betrachten, ein genereller Hinweis: Je länger unser Code wird, desto unübersichtlicher wird er auch. Wir sollten längeren Code deshalb über mehrere Zeilen aufteilen und durch Einrücken kennzeichnen, welche Codesegmente zusammengehörig sind. Das Einrücken übernimmt RStudio weitestgehend automatisch, wir können aber auch selbst Tabs hinzufügen oder entfernen um Zeilen einzurücken. Eine übersichtlicher formatierte, inhaltlich aber identische Version des vorangegangenen Codes könnte wie folgt aussehen: tibble( numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE) ) ## # A tibble: 3 × 3 ## numbers strings logicals ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 zero FALSE ## 2 1 one TRUE ## 3 2 two TRUE R interpretiert dies identisch zur Schreibweise in einer Zeile und weiß, dass alles zwischen der öffnenden und schließenden Klammer Teil der aufgerufenen Funktion ist. Lassen sie uns nun den Output betrachten. Dieser ist grundsätzlich ähnlich zu dem Output eines Dataframes, wobei 2 Unterschiede bestehen. Zum Einen wird der Datentyp einer Spalte unter deren Namen abgebildet. Zum Anderen werden längere Tibbles verkürzt abgedruckt, wie wir später noch sehen werden. Dataframes werden hingegen stets vollständig gedruckt, was bei großen Datenmengen nur dazu führt, dass in der Konsole eigentlich nichts mehr lesbar ist. Ein weiterer wichtiger Unterschied besteht im Subsetting von Tibbles. Das Subsetting mit [] gibt uns immer einen neuen tibble zurück, mit [[]] bekommen wir einen Vektor. Sind wir nur an Spalten interessiert, reicht es übrigens nur die Spaltenposition zwischen den Klammern einzutragen. So bekommen wir die komplette Spalte, also über alle Zeilen, zurück. Alternativ zur numerischen Position, können wir auch die Spaltennamen nutzen. Entweder zwischen den eckigen Klammern oder in der $-Notation. tbl_exmpl &lt;- tibble( numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE) ) str(tbl_exmpl[1]) ## tibble [3 × 1] (S3: tbl_df/tbl/data.frame) ## $ numbers: num [1:3] 0 1 2 str(tbl_exmpl[[1]]) ## num [1:3] 0 1 2 str(tbl_exmpl[[&quot;numbers&quot;]]) ## num [1:3] 0 1 2 str(tbl_exmpl$numbers) ## num [1:3] 0 1 2 Viele tidyverse Funktionen nutzen Tibbles statt Dataframes – so auch die Funktionen des tidytext Packages, welches wir im Verlaufe des Seminars ausgiebig nutzen werden – und Funktionen aus anderen Packages werden meist Dataframes zurückgeben. Wir können beide Datenobjekte aber auch konvertieren. Dazu nutzen wir die base R Funktion as.data.frame() bzw. die dplyr Funktion as_tibble(). str(tbl_exmpl) ## tibble [3 × 3] (S3: tbl_df/tbl/data.frame) ## $ numbers : num [1:3] 0 1 2 ## $ strings : chr [1:3] &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi [1:3] FALSE TRUE TRUE df_exmpl &lt;- as.data.frame(tbl_exmpl) str(df_exmpl) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ numbers : num 0 1 2 ## $ strings : chr &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi FALSE TRUE TRUE tbl_exmpl_2 &lt;- as_tibble(df_exmpl) str(tbl_exmpl_2) ## tibble [3 × 3] (S3: tbl_df/tbl/data.frame) ## $ numbers : num [1:3] 0 1 2 ## $ strings : chr [1:3] &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi [1:3] FALSE TRUE TRUE 2.2.3 Die Pipe %&gt;% Ein weiteres Element des tidyverse ist die sogenannte Pipe %&gt;%. Diese ermöglicht das Aneinanderketten von Befehlen, wobei das Ergebnis des vorangegangenen Befehls an den nächsten weitergegeben wird. Dies klingt im Moment noch sehr abstrakt. Betrachten wir also ein praktisches Beispiel. Folgender Code hat das Ziel, für einen Vektor von Zahlen den auf eine Nachkommastelle gerundeten Mittelwert zu berechnen. Dazu müssen wir zunächt den Vektor erstellen und einem Objekt zuweisen, dann den Mittelwert berechnen und erneut einem Objekt zuweisen und in einem letzten Schritt das Runden mit der Funktion round() vornehmen. Das Argument digits = legt dabei die Anzahl der Nachkommastellen fest. data &lt;- c(4.8, 15.16, 23.42) mean_data &lt;- mean(data) round(mean_data, digits = 1) ## [1] 14.5 Dies funktioniert, wir mussten dazu aber auch jeden Zwischenschritt in ein neues Objekt speichern. Nutzen wir stattdessen die Pipe, umgehen wir diese Notwendigkeit und schreiben gleichzeitig kompakteren und intuitiveren Code. data &lt;- c(4.8, 15.16, 23.42) data %&gt;% mean() %&gt;% round(digits = 1) ## [1] 14.5 Die Pipe nimmt das Ergebnis einer Zeile und gibt dieses an die nächste Zeile weiter. Betrachten wir dieses Beispiel Schritt für Schritt: Die erste Pipe gibt das Objekt data an die Funktion mean() weiter. Wie Sie sehen steht dieses mal kein Argument zwischen den Klammern. Trotzdem weiß R, dass mean() auf das Objekt data angewandt werden soll. Dies funktioniert, da die Pipe immer das Ergebnis der vorangegangenen Zeile als erstes Argument der Funktion in der folgenden Zeile einfügt. So wird hier mean() tatsächlich auf das Objekt data angewandt. Das Ergebnis, der Mittelwert, wird durch die nächste Pipe an die letzte Zeile weitergegeben und eneut als erstes Argument eingesetzt, hier in die Funktion round(). Die Rundung wird also auf den in der Zeile zuvor berechneten Mittelwert angewandt. Dies funktioniert reibungslos mit allen Funktionen, die ein Datenobjekt, auf das sie angewandt werden sollen, als erstes Argument nehmen. Dies ist sehr häufig der Fall, aber nicht immer. Der resultierende Code ist intuitiver zu lesen und weniger schreibintensiv, insbesondere wenn Sie sich früh angewöhnen die pipe mit der Tastenkombination “Ctrl” + “Shift” + “M” einzufügen. Das Endergebnis einer Pipe Operation können wir ebenfalls einem Objekt zuweisen. Die Objektzuweisung erfolt dabei allerdings bereits in der ersten Zeile. rounded_mean &lt;- data %&gt;% mean() %&gt;% round(digits = 1) Dies ist auf den ersten Blick etwas unintuitiv, da nicht data dem Objekt rounded_mean zugewiesen wird, sondern das Ergebnis der letzten Zeile, also der gerundetete Mittelwert. 2.3 Hilfe? 2.3.1 Hilfe! Wir haben nun bereits einige R Funktionen kennengelernt und eine ungefähre Idee davon, was diese machen. Wie bekommen wir aber weitere Informationen zu diesen und neuen Funktionen, zu deren Funktionsweise, den zugelassenen Argumenten oder den zurückgegebenen Ergebnissen? Der einfachste Weg ist das Nutzen der eingebauten Hilfefunktionalitäten in R. Dazu schreiben wir in der Konsole einfach ein ? vor den Namen einer Funktion, zu der wir Hilfe benötigen. Die zugehörige Hilfedatei öffnet sich dann im “Help” Tab, rechts-unten. Versuchen wir dies für die Funktion rnorm(). ?rnorm() Die Hilfedatei gibt uns eine ganze Reihe von Informationen. rnorm() ist Teil einer Familie von Funktionen, die sich auf die Normalverteilung beziehen. Dabei ist die Funktionalität von rnorm(), Zufallszahlen aus der Normalverteilung zu generieren. Wir sehen auch, dass wir der Funktion 3 Argumente geben können. Die Anzahl der zu erzeugenden Zufallszahlen n sowie Mittelwert mean und Standardabweichung sd der zugrundeliegenden Normalverteilung. Dabei ist zu erkennen, dass mean und sd die Standardwerte 0 beziehungsweise 1 haben. Diese werden automatisch eingesetzt, wenn wir sie im Funktionsaufruf nicht durch neue Werte ersetzen. n hat keinen Standardwert, hier müssen wir also einen Wert angeben wenn wir die Funktion aufrufen. rnorm(n = 10) ## [1] 0.60025971 0.37821955 2.49784226 -1.22865543 -0.92235903 -0.70127570 ## [7] 0.43921998 0.42615397 -0.05356045 -0.68105414 So bekommen wir 10 Zufallswerte aus der Normalverteilung mit dem Mittelwert 0 und der Standardabweichung 1. Da es sich um Zufallszahlen handelt, wird Ihr Output von dem auf der Website dargestellten abweichen. Möchten wir Mittelwert und Standardabweichung anpassen, können wir die entsprechenden Argumente nutzen um die Standardwerte durch andere zu ersetzen. rnorm(n = 10, mean = 10, sd = 0.5) ## [1] 10.163082 10.231449 9.579399 10.112432 9.121236 10.177460 10.107783 ## [8] 9.366034 10.258609 10.041621 Neben der Hilfefunktion, stellen viele Packages sogenannte vignettes bereit: Hilfedateien, die in die Funktionalitäten des Packages einführen. Schauen wir uns dies für das tibble Package an: vignette(package = &quot;tibble&quot;) Wir bekommen so eine Liste mit allen zu tibble verfügbaren vignettes zurück. Einzelne dieser vignettes, rufen wir wie folgt auf: vignette(&quot;types&quot;) Eine ausführlichere Dokumentation zu einem Package, finden Sie außerdem meist auf der dazugehörigen CRAN Seite, hier z.B. für tibble: https://cran.r-project.org/web/Packages/tibble/index.html. 2.3.2 Empfohlene externe Resourcen Es gibt eine Vielzahl von Websites und Büchern zu R und RStudio. Einige davon möchte ich hier vorstellen. Die Website von RStudio umfasst eine große Sammlung von Resourcen zu R und der Arbeit mit spezfischen Packages, darunter auch viele Webinare und Tutorial Videos. Diese finden sie unter dem Menüpunkt “Resources” auf: https://www.rstudio.com/ Die RStudio Cheatsheets zu einigen der beliebteren Packages bieten auf kleinem Raum meist sehr gut zusammengefasste Informationen zu den Funktionen und der Arbeitsweise eines Packages. Die Nutzung der Cheatsheets sei von mir dringend empfohlen, und sie sind nicht nur beim Erlernen eines neuen Packages sondern auch als Erinnerungsstütze extrem hilfreich: https://www.rstudio.com/resources/cheatsheets/ Eine weitere Sammlung von Tutorials zu unterschiedlichsten R Themen finden Sie auf “R-bloggers”: https://www.r-bloggers.com/ Generell finden Sie im Internet eine kaum überschaubare Fülle von Informationen und Resourcen zu R und spezifischen Packages in Form von Videos, Blogs, digitalen Büchern und vor allem auch Foreneinträgen – beispielsweise auf https://stackoverflow.com/. So ist einer der wichtigsten Skills, den Sie entwickeln müssen, das Formulieren von klaren und kurzen Suchanfragen zu Ihrem spezifischen R Problem. In der Regel können Sie davon ausgehen, dass die Antwort bereits im Netz existiert. Ihre Aufgabe ist es nun, ihr Problem gut genug zu verstehen und eine entsprechende Suchanfrage zu schreiben, um auf diese wertvollen Resourcen zugreifen zu können. Das Internet gibt Ihnen ebenfalls Zugang zu einer Vielzahl umfassender Einführungen in R sowie zu Online Versionen von R Büchern: Intro to R for Social Scientists von Jasper Tjaden. Eine an Einsteiger*innen gerichtete Einführung in R, die über das in diesem Seminar gelernte R Basiswissen hinausgeht. Geschrieben als Begleitmaterial zu einem Seminar an der Universität Potsdam im Sommersemester 2021. https://jaspertjaden.github.io/course-intro2r/ R Cookbook, 2nd Edition von J.D. Long &amp; Paul Teetor. Das Kochbuch besteht aus einer Reihe von Rezepten für spezifische Aufgaben, die Sie in R durchführen möchten. Dies ist weniger als durchgängig zu lesendes Buch und mehr als Nachschlagewerk zu nutzen. https://rc2e.com/ R for Data Science von Hadley Wickham &amp; Garrett Grolemund. Eine Einführung in die Datenanalyse mit R, fokussiert auf die Arbeit mit dem tidyverse. Geschrieben von zwei zentralen Figuren des tidyverse und Mitarbeitern bei RStudio. https://r4ds.had.co.nz/ "],["R3.html", "3 Transformation und Analyse mit dplyr 3.1 Die Stammdaten des 19. Bundestags 3.2 Datentransformation mit dplyr 3.3 Speichern der transformierten Daten 3.4 Deskriptive Datenanalyse mit dplyr 3.5 Export von Tabellen", " 3 Transformation und Analyse mit dplyr 3.1 Die Stammdaten des 19. Bundestags Dieses und das folgende Kapitel behandeln die Bereinigung, Transformation und deskriptive statistische Analyse von Daten mit dplyr sowie die graphische Analyse mit ggplot2. Zur Veranschaulichung analysieren wir eine Auswahl biographischer Daten der Bundestagsabgeordneten des 19. Bundestags. Darunter sind auch die Regierungsmitglieder und Funktionsträger wie Bundestagspräsident*innen. Die Daten stammen aus einer vom Bundestag bereitgestellten “.xml” Datei und wurden am 07.09.2021 unter folgender URL heruntergeladen: https://www.bundestag.de/services/opendata Das Script zur Extraktion der interessierenden Variablen aus den XML Daten und der Konstruktion des hier genutzten tibbles, finden Sie in meinem GitHub: https://github.com/JakobTures/quanti-text/blob/master/scripts/stammdaten.R Das Script speichert eine Tibble mit allen genutzten Daten in der Datei “stammdaten.RData”, die von Seminarteilnehmer*innen auch in Moodle heruntergeladen werden kann. Laden wir diese Daten zunächst in R. Da es sich bei dem Datenobjekt um eine Tibble handelt, müssen wir auch zunächst das tidyverse package laden. R kennt ohne dieses keine Tibbles und interpretiert das Objekt als Dataframe. library(tidyverse) load(&quot;stammdaten.RData&quot;) Die Datei enthielt das Objekt stammdaten, eine Tibble, der die ausgewählten Stammdaten aller jetzigen und ehemaligen Bundestagsabgeordneten enthält. Schauen wir uns die Tibble einmal an: stammdaten ## # A tibble: 4,089 × 9 ## nachname vorname Titel geschlecht Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. … männlich CDU 5 11 86 20.10… ## 2 Achenbach Ernst Dr. männlich FDP 3 7 108 09.04… ## 3 Ackermann Annemarie &lt;NA&gt; weiblich CDU 2 4 104 26.05… ## 4 Ackermann Else Dr. weiblich CDU 11 12 83 06.11… ## 5 Adam Ulrich &lt;NA&gt; männlich CDU 12 16 67 09.06… ## 6 Adams Rudolf &lt;NA&gt; männlich SPD 5 8 97 10.11… ## 7 Adelmann Raban &lt;NA&gt; männlich CDU 3 3 104 28.09… ## 8 Adenauer Konrad Dr. männlich CDU 1 5 141 05.01… ## 9 Adler Brigitte &lt;NA&gt; weiblich SPD 11 14 73 22.06… ## 10 Adorno Eduard &lt;NA&gt; männlich CDU 4 6 96 31.10… ## # … with 4,079 more rows Die Tibble enthält 4089 Zeilen, also Daten zu 4089 Abgeordneten. Zu jeder Beobachtung stehen 9 Variablen bereit. Nachname, Vorname, akademischer Titel, Geschlecht, Parteizugehörigkeit, die erste und letzte Wahlperiode, in der das MdB im Bundestag vertreten war, sowie Alter und Geburtsdatum. Wie Sie sehen, werden bei Tibbles standardmäßig nur die ersten 10 Zeilen gedruckt. Die Darstellung ist dadurch kompakt und übersichtlich. Eventuell könnten wir aber daran interessiert sein mehr als 10 Zeilen zu sehen. Ein Weg ist das Anklicken des Objekts im “Environment” Tab oder das Schreiben von View(objektname) in der console. Nun öffnet sich das Objekt in einem neuen Tab und kann komplett betrachtet werden. Ein anderer Weg ist es, R zu zwingen mehr Zeilen in die console abzudrucken. Dies ist mit der Funktion print() möglich. Als zweites Argument können wir mit n = angeben, wie viele Zeilen wir sehen möchten. print(stammdaten, n = 20) ## # A tibble: 4,089 × 9 ## nachname vorname Titel geschlecht Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. … männlich CDU 5 11 86 20.10… ## 2 Achenbach Ernst Dr. männlich FDP 3 7 108 09.04… ## 3 Ackermann Annemarie &lt;NA&gt; weiblich CDU 2 4 104 26.05… ## 4 Ackermann Else Dr. weiblich CDU 11 12 83 06.11… ## 5 Adam Ulrich &lt;NA&gt; männlich CDU 12 16 67 09.06… ## 6 Adams Rudolf &lt;NA&gt; männlich SPD 5 8 97 10.11… ## 7 Adelmann Raban &lt;NA&gt; männlich CDU 3 3 104 28.09… ## 8 Adenauer Konrad Dr. männlich CDU 1 5 141 05.01… ## 9 Adler Brigitte &lt;NA&gt; weiblich SPD 11 14 73 22.06… ## 10 Adorno Eduard &lt;NA&gt; männlich CDU 4 6 96 31.10… ## 11 Aerssen Jochen Dr. männlich CDU 8 9 76 15.04… ## 12 Agatz Willi &lt;NA&gt; männlich KPD 1 1 113 10.06… ## 13 Ahlers Conrad &lt;NA&gt; männlich SPD 7 8 94 08.11… ## 14 Ahrens Adolf &lt;NA&gt; männlich DP 1 1 138 17.09… ## 15 Ahrens Hermann &lt;NA&gt; männlich SPD 5 5 115 08.04… ## 16 Ahrens Karl Dr. männlich SPD 6 11 93 13.03… ## 17 Aigner Heinrich Dr. männlich CSU 3 8 93 25.05… ## 18 Alber Siegbert Prof. … männlich CDU 6 8 81 27.07… ## 19 Albers Johannes &lt;NA&gt; männlich CDU 1 2 127 08.03… ## 20 Albertz Luise &lt;NA&gt; weiblich SPD 1 5 116 22.06… ## # … with 4,069 more rows 3.2 Datentransformation mit dplyr Das dplyr package enthält eine Reihe von Funktionen zur Bereinigung, Transformation und deskriptiven Analyse von Daten. Wir beginnen damit, Zeilen und Spalten, die wir nicht benötigen, aus der Tibble zu entfernen, bevor wir die Daten in einigen bestehenden Spalten transformieren und neue Spalten aus den vorhandenen Daten erzeugen. Empfohlene weiterführende Resourcen zu dplyr sind das entsprechende RStudio Cheatsheet: https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-transformation.pdf sowie das Kapitel “Data transformation” in “R for Data Science”: https://r4ds.had.co.nz/transform.html 3.2.1 filter() filter() dient dazu, Beobachtungen – also Zeilen – aus einer Tibble zu filtern. Die Funktion nimmt dabei die Daten, auf die sie angewandt werden soll, als erstes und eine oder mehrere expressions als zweites Argument. Diese Ausdrücke sind letztlich die Regeln, nach denen die Funktion filtern soll. Zum Schreiben der Ausdrücke benötigen wir die in Kapitel 1.2.4 bereits eingeführten Vergleichsoperatoren. Diese vergleichen den Wert auf der linken Seite des Operators mit dem auf der rechten und geben als Ergebnis ein TRUE zurück, wenn der Test bestanden wurde, beziehungsweise FALSE, wenn er nicht bestanden wurde. Wir könnten nun beispielsweise daran interessiert sein, nur die Daten bestimmter Parteien zu analysieren. Filtern wir zunächst die Stammdaten der CDU-Abgeordneten heraus. Wir können dazu in filter() testen, ob der Wert der Spalte “Partei” gleich dem Wert “CDU” ist. Bitte denken Sie daran, dass wir zum Vergleich zweier Werte immer == schreiben müssen, nicht =. stammdaten %&gt;% filter(Partei == &quot;CDU&quot;) ## # A tibble: 1,347 × 9 ## nachname vorname Titel geschlecht Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. … männlich CDU 5 11 86 20.10… ## 2 Ackermann Annemarie &lt;NA&gt; weiblich CDU 2 4 104 26.05… ## 3 Ackermann Else Dr. weiblich CDU 11 12 83 06.11… ## 4 Adam Ulrich &lt;NA&gt; männlich CDU 12 16 67 09.06… ## 5 Adelmann Raban &lt;NA&gt; männlich CDU 3 3 104 28.09… ## 6 Adenauer Konrad Dr. männlich CDU 1 5 141 05.01… ## 7 Adorno Eduard &lt;NA&gt; männlich CDU 4 6 96 31.10… ## 8 Aerssen Jochen Dr. männlich CDU 8 9 76 15.04… ## 9 Alber Siegbert Prof. … männlich CDU 6 8 81 27.07… ## 10 Albers Johannes &lt;NA&gt; männlich CDU 1 2 127 08.03… ## # … with 1,337 more rows Möchten wir mehrere Ausdrücke kombinieren, benötigen wir dazu logische Operatoren. &amp; – UND – testet, ob beide verbundenen Ausdrücke gleichzeitig TRUE sind und gibt nur dann TRUE zurück. | – ODER – testet, ob wenigstens einer der verbundenen Ausdrücke TRUE ist und gibt in diesem Fall TRUE zurück. Dies sind alle möglichen Kombinationen für 2 Ausdrücke: TRUE &amp; TRUE gibt TRUE zurück TRUE &amp; FALSE, FALSE &amp; TRUE und FALSE &amp; FALSE geben alle FALSE zurück TRUE | TRUE, TRUE | FALSE und FALSE | TRUE geben alle TRUE zurück FALSE | FALSE gibt FALSE zurück Möchten wir nun beispielsweise alle CDU-Mitglieder des 19. Bundestags filtern, können wir dazu den &amp; Operator einsetzen: stammdaten %&gt;% filter(Partei == &quot;CDU&quot; &amp; letzte_WP == 19) ## # A tibble: 201 × 9 ## nachname vorname Titel geschlecht Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Bleser Peter &lt;NA&gt; männlich CDU 12 19 65 23.07… ## 2 Fuchtel Hans-Joachim &lt;NA&gt; männlich CDU 11 19 65 13.02… ## 3 Kauder Volker &lt;NA&gt; männlich CDU 12 19 68 03.09… ## 4 Landgraf Katharina &lt;NA&gt; weiblich CDU 11 19 63 24.02… ## 5 Merkel Angela Dr. weiblich CDU 12 19 63 17.07… ## 6 Schäuble Wolfgang Dr. männlich CDU 7 19 75 18.09… ## 7 Stübgen Michael &lt;NA&gt; männlich CDU 12 19 57 17.10… ## 8 Altmaier Peter &lt;NA&gt; männlich CDU 13 19 59 18.06… ## 9 Gröhe Hermann &lt;NA&gt; männlich CDU 13 19 56 25.02… ## 10 Grund Manfred &lt;NA&gt; männlich CDU 13 19 62 03.07… ## # … with 191 more rows Statt mit &amp; können wir in filter() Ausdrücke auch mit , verbinden. Das | lässt sich aber nicht auf ähnlichem Weg ersetzen. Möchten wir Unionsmitglieder filtern, also CDU- oder CSU-Mitglieder, können wir dies mit | realisieren: stammdaten %&gt;% filter(Partei == &quot;CDU&quot; | Partei == &quot;CSU&quot;) ## # A tibble: 1,616 × 9 ## nachname vorname Titel geschlecht Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. … männlich CDU 5 11 86 20.10… ## 2 Ackermann Annemarie &lt;NA&gt; weiblich CDU 2 4 104 26.05… ## 3 Ackermann Else Dr. weiblich CDU 11 12 83 06.11… ## 4 Adam Ulrich &lt;NA&gt; männlich CDU 12 16 67 09.06… ## 5 Adelmann Raban &lt;NA&gt; männlich CDU 3 3 104 28.09… ## 6 Adenauer Konrad Dr. männlich CDU 1 5 141 05.01… ## 7 Adorno Eduard &lt;NA&gt; männlich CDU 4 6 96 31.10… ## 8 Aerssen Jochen Dr. männlich CDU 8 9 76 15.04… ## 9 Aigner Heinrich Dr. männlich CSU 3 8 93 25.05… ## 10 Alber Siegbert Prof. … männlich CDU 6 8 81 27.07… ## # … with 1,606 more rows Es lassen sich auch mehr als zwei Ausdrücke mit &amp;und | kombinieren. stammdaten %&gt;% filter(Partei == &quot;CDU&quot; | Partei == &quot;CSU&quot; | Partei == &quot;FDP&quot; | Partei == &quot;AfD&quot;) ## # A tibble: 2,164 × 9 ## nachname vorname Titel geschlecht Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. … männlich CDU 5 11 86 20.10… ## 2 Achenbach Ernst Dr. männlich FDP 3 7 108 09.04… ## 3 Ackermann Annemarie &lt;NA&gt; weiblich CDU 2 4 104 26.05… ## 4 Ackermann Else Dr. weiblich CDU 11 12 83 06.11… ## 5 Adam Ulrich &lt;NA&gt; männlich CDU 12 16 67 09.06… ## 6 Adelmann Raban &lt;NA&gt; männlich CDU 3 3 104 28.09… ## 7 Adenauer Konrad Dr. männlich CDU 1 5 141 05.01… ## 8 Adorno Eduard &lt;NA&gt; männlich CDU 4 6 96 31.10… ## 9 Aerssen Jochen Dr. männlich CDU 8 9 76 15.04… ## 10 Aigner Heinrich Dr. männlich CSU 3 8 93 25.05… ## # … with 2,154 more rows Die Daten enthalten aktuell noch alle Abgeordneten, die jemals ein Mandat im Bundestag hatten. Mit filter() können wir den Datensatz auf diejenigen reduzieren, die auch im 19. Bundestag vertreten waren. stammdaten_19 &lt;- stammdaten %&gt;% filter(letzte_WP == 19) Ab hier arbeiten wir mit dem Objekt stammdaten_19 weiter. 3.2.2 select() Möchten wir ein Subset von Variablen bilden, könne wir dazu select() nutzen. Die Funktion nimmt die Daten, auf die sie angewendet werden soll, als erstes Argument – hier weitergegeben durch die Pipe – und dann einen oder mehrere Spaltennamen, die in der Tibble verbleiben sollen. Folgen die zu behaltenden Spalten aufeinander, können wir auch eine “von:bis” Notation nutzen. Nehmen wir an, wir möchten die Spalten “nachname”, “vorname”, “Titel” und “Partei” extrahieren: stammdaten_19 %&gt;% select(nachname, vorname, Titel, Partei) ## # A tibble: 732 × 4 ## nachname vorname Titel Partei ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Bleser Peter &lt;NA&gt; CDU ## 2 Brecht Eberhard Dr. SPD ## 3 Dehm Diether Dr. DIE LINKE. ## 4 Fuchtel Hans-Joachim &lt;NA&gt; CDU ## 5 Gysi Gregor Dr. DIE LINKE. ## 6 Jelpke Ulla &lt;NA&gt; DIE LINKE. ## 7 Kauder Volker &lt;NA&gt; CDU ## 8 Kubicki Wolfgang &lt;NA&gt; FDP ## 9 Landgraf Katharina &lt;NA&gt; CDU ## 10 Matschie Christoph &lt;NA&gt; SPD ## # … with 722 more rows stammdaten_19 %&gt;% select(nachname:Titel, Partei) ## # A tibble: 732 × 4 ## nachname vorname Titel Partei ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Bleser Peter &lt;NA&gt; CDU ## 2 Brecht Eberhard Dr. SPD ## 3 Dehm Diether Dr. DIE LINKE. ## 4 Fuchtel Hans-Joachim &lt;NA&gt; CDU ## 5 Gysi Gregor Dr. DIE LINKE. ## 6 Jelpke Ulla &lt;NA&gt; DIE LINKE. ## 7 Kauder Volker &lt;NA&gt; CDU ## 8 Kubicki Wolfgang &lt;NA&gt; FDP ## 9 Landgraf Katharina &lt;NA&gt; CDU ## 10 Matschie Christoph &lt;NA&gt; SPD ## # … with 722 more rows Wir können select()auch nutzen, um Variablen zu entfernen. Dazu schreiben wir - vor den zu entfernenden Spaltennamen. Da das genaue Geburtsdatum der Abgeordneten im Folgenden nicht mehr benötigt wird, können wir die Spalte “geb” entfernen. “letzte_WP” kann ebenfalls entfernt werden, da die Spalte nach dem Filtern keine Informationen mehr enthält. Ihr Wert ist für alle Beobachtungen 19. stammdaten_19 &lt;- stammdaten_19 %&gt;% select(-c(geb, letzte_WP)) stammdaten_19 ## # A tibble: 732 × 7 ## nachname vorname Titel geschlecht Partei erste_WP alter ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Bleser Peter &lt;NA&gt; männlich CDU 12 65 ## 2 Brecht Eberhard Dr. männlich SPD 12 67 ## 3 Dehm Diether Dr. männlich DIE LINKE. 12 67 ## 4 Fuchtel Hans-Joachim &lt;NA&gt; männlich CDU 11 65 ## 5 Gysi Gregor Dr. männlich DIE LINKE. 11 69 ## 6 Jelpke Ulla &lt;NA&gt; weiblich DIE LINKE. 12 66 ## 7 Kauder Volker &lt;NA&gt; männlich CDU 12 68 ## 8 Kubicki Wolfgang &lt;NA&gt; männlich FDP 12 65 ## 9 Landgraf Katharina &lt;NA&gt; weiblich CDU 11 63 ## 10 Matschie Christoph &lt;NA&gt; männlich SPD 12 56 ## # … with 722 more rows 3.2.3 rename() Ihnen wird eventuell bereits aufgefallen sein, dass die meisten Spaltennamen mit einem kleingeschriebenen Buchstaben beginnen, “Titel” und “Partei” aber nicht. Da habe ich anscheinend beim Erstellen des Datenobjekts meine eigenen Namenskonventionen – alles beginnt mit kleinen Buchstaben – außer Acht gelassen. Um diese nun umzubenennen, können wir rename() nutzen. Erneut werden als erstes Argument die Daten durch die Pipe weitergegeben, gefolgt von einem oder mehreren Argumenten in der Form neuer_name = alter_name. stammdaten_19 &lt;- stammdaten_19 %&gt;% rename(titel = Titel, partei = Partei) stammdaten_19 ## # A tibble: 732 × 7 ## nachname vorname titel geschlecht partei erste_WP alter ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Bleser Peter &lt;NA&gt; männlich CDU 12 65 ## 2 Brecht Eberhard Dr. männlich SPD 12 67 ## 3 Dehm Diether Dr. männlich DIE LINKE. 12 67 ## 4 Fuchtel Hans-Joachim &lt;NA&gt; männlich CDU 11 65 ## 5 Gysi Gregor Dr. männlich DIE LINKE. 11 69 ## 6 Jelpke Ulla &lt;NA&gt; weiblich DIE LINKE. 12 66 ## 7 Kauder Volker &lt;NA&gt; männlich CDU 12 68 ## 8 Kubicki Wolfgang &lt;NA&gt; männlich FDP 12 65 ## 9 Landgraf Katharina &lt;NA&gt; weiblich CDU 11 63 ## 10 Matschie Christoph &lt;NA&gt; männlich SPD 12 56 ## # … with 722 more rows 3.2.4 mutate() mutate() dient dazu, Daten in bestehenden Spalten zu transformieren und neue Spalten aus den Daten bestehender Spalten zu generieren. Aktuell ist der Name der Abgeordneten über zwei Spalten verteilt. Möchten wir stattdessen eine Spalte mit dem kompletten Namen erstellen, können wir dies mit mutate() umsetzen. Generell schreiben wir innerhalb der Klammern den Namen der zu transformierenden oder neu zu erstellenden Spalte = einem Ausdruck der beschreibt, wir die Daten transformiert oder generiert werden sollen. Dies kann eine einfache Berechnung wie mutate(neue_spalte = spalte_a + spalte b) sein, aber auch weitere Funktionen beinhalten. Hier nutzen wir die Funktion str_c() aus dem core tidyverse Package stringr, um zwei Strings zu einem zu kombinieren. Das optionale Argument sep = wird dazu genutzt um festzulegen, welche Zeichen zwischen die zu kombinierenden Strings eingefügt werden. Setzen wir dies um und betrachten die neue sowie die alten Spalten: stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(name = str_c(nachname, vorname, sep = &quot;, &quot;)) stammdaten_19 %&gt;% select(nachname, vorname, name) ## # A tibble: 732 × 3 ## nachname vorname name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Bleser Peter Bleser, Peter ## 2 Brecht Eberhard Brecht, Eberhard ## 3 Dehm Diether Dehm, Diether ## 4 Fuchtel Hans-Joachim Fuchtel, Hans-Joachim ## 5 Gysi Gregor Gysi, Gregor ## 6 Jelpke Ulla Jelpke, Ulla ## 7 Kauder Volker Kauder, Volker ## 8 Kubicki Wolfgang Kubicki, Wolfgang ## 9 Landgraf Katharina Landgraf, Katharina ## 10 Matschie Christoph Matschie, Christoph ## # … with 722 more rows Die Spalte “titel” listet aktuell die akademischen Titel der Abgeordneten. Liegt ein Titel vor, wird dieser genau benannt. Liegt keiner vor enthält die Spalte ein NA, die Repräsentation fehlender Werte in R. Für diese Analyse interessiert uns nur, ob ein Titel vorliegt, aber nicht welcher. Dazu könnten wir eine neue Spalte generieren, welche einen logischen Vektor enthält, der angibt, ob ein Titel vorliegt (TRUE) oder nicht (FALSE). Dies ist eine sogenannte Dummyvariable. Zum Generieren können wir die dplyr Funktion if_else() nutzen. Wir geben als erstes Argument eine Bedingung an, die getestet wird. Hier !is.na(titel), welche testet ob der Inhalt von “titel” nicht – angezeigt durch das ! – missing ist. Das zweite und dritte Argument geben an, was eingesetzt werden soll wenn die getestete Bedingung erfüllt beziehungsweise nicht erfüllt ist. Hier soll im ersten Fall TRUE, im zweiten FALSE eingesetzt werden. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(titel_dummy = if_else(!is.na(titel), TRUE, FALSE)) stammdaten_19 %&gt;% select(titel, titel_dummy) ## # A tibble: 732 × 2 ## titel titel_dummy ## &lt;chr&gt; &lt;lgl&gt; ## 1 &lt;NA&gt; FALSE ## 2 Dr. TRUE ## 3 Dr. TRUE ## 4 &lt;NA&gt; FALSE ## 5 Dr. TRUE ## 6 &lt;NA&gt; FALSE ## 7 &lt;NA&gt; FALSE ## 8 &lt;NA&gt; FALSE ## 9 &lt;NA&gt; FALSE ## 10 &lt;NA&gt; FALSE ## # … with 722 more rows Die Spalte “partei” ist auch als Character Vektor abgelegt. Bei der Parteizugehörigkeit handelt es sich um eine kategoriale Variable. So gibt es nur eine begrenzte Anzahl möglicher Ausprägungen, nämlich die Namen der im 19. Bundestag vertretenen Parteien sowie die Kategorie “Plos” für Parteilose. Die Repräsentation kategorialer Variablen in R nennt sich factor. Das core tidyverse Package forcats ermöglicht es uns, Faktorvariablen anzulegen und zu manipulieren. Dies erleichtert vor allem die graphische Analyse im weiteren Verlauf des Kapitels. Der einfachste Weg ist es, R selbst auslesen zu lassen, welche Kategorien in einer Variable vorhanden sind. Dazu wenden wir einfach die Funktion factor() innerhalb von mutate() auf eine Spalte an. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(partei = factor(partei)) Um herauszufinden, welche Kategorien ein factor vector umfasst, nutzen wir levels(). levels(stammdaten_19$partei) ## [1] &quot;AfD&quot; &quot;BÜNDNIS 90/DIE GRÜNEN&quot; &quot;CDU&quot; ## [4] &quot;CSU&quot; &quot;DIE LINKE.&quot; &quot;FDP&quot; ## [7] &quot;Plos&quot; &quot;SPD&quot; Dies scheint funktioniert zu haben, es fallen aber auch zwei Probleme auf, um die wir uns noch kümmern sollten. Erstens könnten wir daran interessiert sein, die Union als Ganzes zu analysiseren. Zweitens sind die Kategorien aktuell alphabetisch geordnet, inhaltlicher sinnvoller wäre aber beispielsweise eine Ordnung nach der Größe der Fraktionen im 19. Bundestag. Fassen wir zuerst “CDU” und “CDU” zur “Union” zusammen. Dazu können wir fct_collapse() nutzen. Dabei geben wir vor dem = den Namen der neuen Kategorie an, nach dem = mit c() kombiniert die Namen der alten Kategorien, die wir zusammenfassen möchten. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(partei = fct_collapse(partei, Union = c(&quot;CDU&quot;, &quot;CSU&quot;))) levels(stammdaten_19$partei) ## [1] &quot;AfD&quot; &quot;BÜNDNIS 90/DIE GRÜNEN&quot; &quot;Union&quot; ## [4] &quot;DIE LINKE.&quot; &quot;FDP&quot; &quot;Plos&quot; ## [7] &quot;SPD&quot; Das Zuammenfassen mehrerer Factors wäre auch mit fct_recode() möglich, erfordert aber etwas mehr Schreibarbeit. Diese Funktion eignet sich aber zum Anpassen der Namen einzelner Factors. Um die Kategorien manuell neu zu ordnen, könnten wir fct_relevel() nutzen. Dazu müssten wir aber die gewünschte Reihenfolge per Hand notieren. Bequemer geht es mit fct_infreq(), welche die Kategorien automatisch nach der Häufigkeit Ihres Auftretens in den Daten ordnet. Also in unserem Fall von der Kategorie mit den meisten Abgeordneten bis zu der mit den wenigsten. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(partei = fct_infreq(partei)) levels(stammdaten_19$partei) ## [1] &quot;Union&quot; &quot;SPD&quot; &quot;AfD&quot; ## [4] &quot;FDP&quot; &quot;BÜNDNIS 90/DIE GRÜNEN&quot; &quot;DIE LINKE.&quot; ## [7] &quot;Plos&quot; Die Spalte “geschlecht” liegt ebenfalls als Character Vektor vor und kann auf dem selben Weg in einen Factor umgewandelt werden. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(geschlecht = factor(geschlecht)) levels(stammdaten_19$geschlecht) ## [1] &quot;männlich&quot; &quot;weiblich&quot; Damit sind die Daten zur weiteren Analyse vorbereitet. Wir können nun noch nicht mehr benötigte Spalten entfernen, um die Tibble übersichtlich zu halten, sowie die dann noch vorhandenen Spalten in eine sinnvollere Reihenfolge bringen. Beides ist nicht zwingend notwendig, führt aber zu einem aufgeräumteren Output der Tibble. Die Spalten “nachname”, “vorname” und “titel” sind nicht mehr notwendig, da wir die enthaltenen Informationen in neue Variablen überführt haben. stammdaten_19 &lt;- stammdaten_19 %&gt;% select(-c(nachname:titel)) stammdaten_19 ## # A tibble: 732 × 6 ## geschlecht partei erste_WP alter name titel_dummy ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 männlich Union 12 65 Bleser, Peter FALSE ## 2 männlich SPD 12 67 Brecht, Eberhard TRUE ## 3 männlich DIE LINKE. 12 67 Dehm, Diether TRUE ## 4 männlich Union 11 65 Fuchtel, Hans-Joachim FALSE ## 5 männlich DIE LINKE. 11 69 Gysi, Gregor TRUE ## 6 weiblich DIE LINKE. 12 66 Jelpke, Ulla FALSE ## 7 männlich Union 12 68 Kauder, Volker FALSE ## 8 männlich FDP 12 65 Kubicki, Wolfgang FALSE ## 9 weiblich Union 11 63 Landgraf, Katharina FALSE ## 10 männlich SPD 12 56 Matschie, Christoph FALSE ## # … with 722 more rows Was eine sinnvolle Reihenfolge der verbleibenden Variablen sein kann ist natürlich subjektiv. Ich würde aber folgende Reihenfolge vorschlagen und mit relocate() umsetzen. Die Syntax funktioniert dabei ähnllich zu select(). stammdaten_19 &lt;- stammdaten_19 %&gt;% relocate(name, titel_dummy, partei, geschlecht, alter, erste_WP) stammdaten_19 ## # A tibble: 732 × 6 ## name titel_dummy partei geschlecht alter erste_WP ## &lt;chr&gt; &lt;lgl&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 Bleser, Peter FALSE Union männlich 65 12 ## 2 Brecht, Eberhard TRUE SPD männlich 67 12 ## 3 Dehm, Diether TRUE DIE LINKE. männlich 67 12 ## 4 Fuchtel, Hans-Joachim FALSE Union männlich 65 11 ## 5 Gysi, Gregor TRUE DIE LINKE. männlich 69 11 ## 6 Jelpke, Ulla FALSE DIE LINKE. weiblich 66 12 ## 7 Kauder, Volker FALSE Union männlich 68 12 ## 8 Kubicki, Wolfgang FALSE FDP männlich 65 12 ## 9 Landgraf, Katharina FALSE Union weiblich 63 11 ## 10 Matschie, Christoph FALSE SPD männlich 56 12 ## # … with 722 more rows 3.3 Speichern der transformierten Daten Wir werden im nächsten Kapitel mit den hier transformierten Daten weiterarbeiten. Dazu sollten Sie entweder zu Beginn des Kapitels das Script aus diesem Kapitel nochmals durchlaufen lassen, oder Sie speichern die bearbeiteten Daten: save(stammdaten_19, file = &quot;stammdaten_19.RData&quot;) 3.4 Deskriptive Datenanalyse mit dplyr 3.4.1 summarise() Die Funktion summarise() ermöglicht es uns, zusammenfassende Maßzahlen zu einer Tibble zu berechnen. Die Syntax funktioniert dabei ähnlich zu mutate(). Wir definieren einen Namen für die Spalte, in der die Maßzahlen gelistet werden sollen, und nach dem = eine entsprechende Berechnung oder Funktion. Das Ergebnis ist ein neue Tibble, welche die angeforderten Statistiken enthält. Betrachten wir zunächst die Spalte “alter”. Wir könnten uns für das arithmetische Mittel des Alters der MdBs interessieren. Dazu definieren wir innerhalb von summarise() den Namen der neuen Spalte und nach dem = nutzen wir die base R Funktion mean(): stammdaten_19 %&gt;% summarise(arith_mittel = mean(alter)) ## # A tibble: 1 × 1 ## arith_mittel ## &lt;dbl&gt; ## 1 49.3 Wir können uns auch mehrere Statistiken gleichzeitig ausgeben, indem wir die entsprechenden Anfragen mit , verbinden: stammdaten_19 %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), median = median(alter), maximum = max(alter)) ## # A tibble: 1 × 4 ## minimum arith_mittel median maximum ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 24 49.3 50 77 Das sieht alles schon ordentlich aus, ist aber auch auf einfacherem Wege erzielbar, beispielsweise mit der praktischen base R Funktion summary(). Wirklich mächtig wird summarise() erst durch die Kombination mit group_by(). So können wir die Daten gruppieren und die zusammenfassenden Statistiken für jede dieser Gruppen separat berechnen. 3.4.2 summarise() &amp; group_by() Unsere Daten bieten sich für eine Analyse nach Parteimitgliedschaft an. Als ersten Schritt können wir die Daten also nach dem Inhalt der Spalte “partei” gruppieren und zunächst einmal zählen, wie viele Abgeordnete pro Partei im Bundestag vertreten sind. Dazu nutzen wir innerhalb von summarise() die dplyr Funktion n(), welche die Anzahl Beobachtungen pro Gruppe, also die Gruppengröße, zurückgibt. stammdaten_19 %&gt;% group_by(partei) %&gt;% summarise(abgeordnete = n()) ## # A tibble: 7 × 2 ## partei abgeordnete ## &lt;fct&gt; &lt;int&gt; ## 1 Union 248 ## 2 SPD 162 ## 3 AfD 88 ## 4 FDP 84 ## 5 BÜNDNIS 90/DIE GRÜNEN 71 ## 6 DIE LINKE. 69 ## 7 Plos 10 Eben haben wir das Durchschnittsalter aller Abgeordneten berechnet. Dies können wir natürlich auch gruppiert nach der Partei machen. stammdaten_19 %&gt;% group_by(partei) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) ## # A tibble: 7 × 7 ## partei minimum arith_mittel std_abweichung median maximum anzahl ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Union 24 49.9 9.69 50.5 75 248 ## 2 SPD 26 50.2 9.42 52 68 162 ## 3 AfD 26 50.8 12.5 49.5 77 88 ## 4 FDP 24 45.6 10.8 46 76 84 ## 5 BÜNDNIS 90/DIE GRÜN… 32 47.1 9.67 48 64 71 ## 6 DIE LINKE. 27 50.1 9.73 52 69 69 ## 7 Plos 31 45.7 8.19 44.5 59 10 Oft ist es hilfreich, die Daten nach einer Statistik, die uns interessiert, zu ordnen. Möchten wir beispielsweise wissen, welche Partei den höchsten beziehungsweise niedrigsten Mittelwert des Alters hat, können wir die Ergebnisse in einem weiteren Schritt mit der Funktion arrange() nach den Werten dieser Variable ordnen. Die zusätzliche Funktion desc() bewirkt, dass die Daten absteigend geordnet werden. stammdaten_19 %&gt;% group_by(partei) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) %&gt;% arrange(desc(arith_mittel)) ## # A tibble: 7 × 7 ## partei minimum arith_mittel std_abweichung median maximum anzahl ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 AfD 26 50.8 12.5 49.5 77 88 ## 2 SPD 26 50.2 9.42 52 68 162 ## 3 DIE LINKE. 27 50.1 9.73 52 69 69 ## 4 Union 24 49.9 9.69 50.5 75 248 ## 5 BÜNDNIS 90/DIE GRÜN… 32 47.1 9.67 48 64 71 ## 6 Plos 31 45.7 8.19 44.5 59 10 ## 7 FDP 24 45.6 10.8 46 76 84 Für die Mehrzahl der Parteien liegt der Mittelwert des Alters bei ca. 50 Jahren. Dabei beträgt die Differenz des arithmetischen Mitels zwischen AfD und Union etwa 1 Jahr. Wir sehen für die AfD aber auch eine höhere Standardabweichung und einen niedrigeren Median. Wir könnten also vermuten, dass in der AfD einige besonders alte Abgeordnete vertreten sind, welche den Mittelwert nach oben verzerren. Die FDP ist dem Mittelwert nach die jüngste, die Grünen die zweitjüngste Partei. Dabei ist auffällig, dass die Grünen die engste Spannweite des Alters aufweisen. Es gibt keine Abgeordneten unter 32 und keine über 64. Die FDP hat demgegenüber sehr junge und sehr alte MdBs. Die Statistiken für die Gruppe der parteilosen sind nicht besonders belastbar, da sie nur aus 10 Personen besteht, deuten aber auf ein relativ junges Durchschnittsalter hin. Diesen ersten Befunden werden wir bei der graphischen Analyse im folgenden Kapitel weiter auf den Grund gehen. Die Spalte “titel_dummy” ist ein logischer Vektor der TRUE enthält, wenn ein MdB einen akademischen Titel besitzt und FALSE, wenn keiner vorliegt. Hinter einem logischen Vektor stehen Zahlenwerte. TRUE ist die Repräsentation von 1, FALSE von 0. Wir können also direkt mit den Werten des Vektors rechnen. Um die absolute Anzahl an Titeln zu berechenn, reicht es so die Summe des Vektors zu bilden. Alle Werte werden aufaddiert und da wir nur Einsen und Nullen haben, ist das Ergebnis gleich der Anzahl der Abgeordneten, die einen akademischen Titel tragen. Um den relativen Anteil zu berechnen, können wir das arithmetische Mittel nutzen. Alle Einsen und Nullen werden aufaddiert und durch die Anzahl der Beobachtungen geteilt. Dies ist der Anteil der Abgeordneten mit Titel. stammdaten_19 %&gt;% summarise(absolut = sum(titel_dummy), relativ = mean(titel_dummy) ) ## # A tibble: 1 × 2 ## absolut relativ ## &lt;int&gt; &lt;dbl&gt; ## 1 143 0.195 Wir könnten uns dafür interessieren, ob sich das Alter der Abgeordneten mit Titel von denen unterscheidet die keinen Titel tragen. Dazu gruppieren wir nach der Spalte “titel_dummy” und berechnen die Statistiken zum Alter. stammdaten_19 %&gt;% group_by(titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) ## # A tibble: 2 × 7 ## titel_dummy minimum arith_mittel std_abweichung median maximum anzahl ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 FALSE 24 48.9 10.1 49 77 589 ## 2 TRUE 28 50.8 10.8 50 76 143 Abgeordnete mit Titel sind im Durchschnitt etwas älter. Dies macht Sinn, da sowohl das Erlangen eines Titels als auch eines Bundestagmandats hohe Zeitinvestitionen darstellen. Wir können auch nach mehreren Spalten gleichzeitig gruppieren. In diesem Fall werden die Statistiken für jede Gruppenkombination berechnet. stammdaten_19 %&gt;% group_by(partei, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) ## `summarise()` has grouped output by &#39;partei&#39;. You can override using the `.groups` argument. ## # A tibble: 14 × 8 ## # Groups: partei [7] ## partei titel_dummy minimum arith_mittel std_abweichung median maximum anzahl ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Union FALSE 24 49.6 9.71 51 70 199 ## 2 Union TRUE 32 51.0 9.63 50 75 49 ## 3 SPD FALSE 26 50.1 9.56 52 68 135 ## 4 SPD TRUE 33 50.8 8.83 49 67 27 ## 5 AfD FALSE 26 49.6 12.0 49 77 68 ## 6 AfD TRUE 28 54.8 13.5 55.5 76 20 ## 7 FDP FALSE 24 44.8 9.79 46 66 67 ## 8 FDP TRUE 31 48.7 13.9 46 76 17 ## 9 BÜNDNI… FALSE 32 48.1 9.75 49 64 55 ## 10 BÜNDNI… TRUE 33 43.8 8.87 42.5 64 16 ## 11 DIE LI… FALSE 27 48.7 9.72 50 66 57 ## 12 DIE LI… TRUE 48 56.8 6.67 56 69 12 ## 13 Plos FALSE 31 45.9 9.14 44.5 59 8 ## 14 Plos TRUE 42 45 4.24 45 48 2 Wir sehen an den Mittelwerten, dass der oben für den gesamten Bundestag analysierte Unterschied im mittleren Alter von MdBs mit und ohne Titel nicht für alle Parteien gleichermaßen gilt. Während Titelträger in AfD, FDP und LINKE im Mittel klar älter sind als Abgeordnete ohne Titel, ist die Differenz für die Union und die SPD sehr gering. Bei den Grünen sind Titelträger im Mittel sogar jünger. Auch dies werden wir in der graphischen Analyse erneut betrachten. An dieser Stelle müssen wir noch über eine Besonderheit in der Zusammenarbeit von group_by() und summarise() sprechen, welche zu Problemen führen kann, wenn Sie sich ihr nicht bewusst sind. Grundsätzlich wird jeder Aufruf von summarise() nach einem group_by() Befehl eine Ebene der Gruppierung auflösen. Für die Beispiele in denen wir nur nach Partei oder Titel gruppiert haben, bedeutet dies also, dass die Daten nach dem summarise() Befehl nicht mehr gruppiert waren. Wir hatten eine Gruppierungsebene und diese wurde automatisch entfernt. Im letzten Beispiel hatten wir zwei Gruppierungsebenen. Von diesen wurde nur die niedrigere Gruppierungsebene – die Reihenfolge der Variablen in group_by() bestimmt auch die Reihenfolge der Gruppierung –, also die Gruppierung nach dem Titel aufgelöst. Die Gruppierung nach der Parteimitgliedschaft ist weiterhin aktiv. Dies ist auch im Output anhand der Zeile # Groups: partei [7] erkennbar. Die Daten sind nach der Partei gruppiert und wir haben 7 Gruppen. Möchten wir mit den Ergebnissen dieser Berechnungen weiterarbeiten, müssen wir uns auch über die Gruppierung bewusst sein. Sollen die Daten weiterhin gruppiert sein? Dann ist alles gut, sollen sie es nicht sein müssen wir die Gruppierung vollständig auflösen. Dies machen wir mit der Funktion ungroup(). Solange Sie sich nicht sicher sind, dass Sie die Gruppierung wirklich weiterhin brauchen, würde ich immer zu einem ungroup() am Ende einer group_by() und summarise() Operation mit mehreren Gruppen tendieren. So verhindern sie versehentliche Berechnungen auf Gruppenbasis und die Gruppierung lässt sich jederzeit schnell wieder herstellen, sollte dies notwendig werden. stammdaten_19 %&gt;% group_by(partei, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) %&gt;% ungroup() ## `summarise()` has grouped output by &#39;partei&#39;. You can override using the `.groups` argument. ## # A tibble: 14 × 8 ## partei titel_dummy minimum arith_mittel std_abweichung median maximum anzahl ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Union FALSE 24 49.6 9.71 51 70 199 ## 2 Union TRUE 32 51.0 9.63 50 75 49 ## 3 SPD FALSE 26 50.1 9.56 52 68 135 ## 4 SPD TRUE 33 50.8 8.83 49 67 27 ## 5 AfD FALSE 26 49.6 12.0 49 77 68 ## 6 AfD TRUE 28 54.8 13.5 55.5 76 20 ## 7 FDP FALSE 24 44.8 9.79 46 66 67 ## 8 FDP TRUE 31 48.7 13.9 46 76 17 ## 9 BÜNDNI… FALSE 32 48.1 9.75 49 64 55 ## 10 BÜNDNI… TRUE 33 43.8 8.87 42.5 64 16 ## 11 DIE LI… FALSE 27 48.7 9.72 50 66 57 ## 12 DIE LI… TRUE 48 56.8 6.67 56 69 12 ## 13 Plos FALSE 31 45.9 9.14 44.5 59 8 ## 14 Plos TRUE 42 45 4.24 45 48 2 3.5 Export von Tabellen Ein flexibler Weg zum direkten Export von Tabellen ist es, diese als “.csv” abzuspeichern. Dieses Format kann wiedrum direkt in Excel importiert werden. Da ich kein aktiver Office Nutzer bin, kann Ich Ihnen hier nur begrenzte praktische Ratschläge geben. Der Import sollte aber im Normalfall möglich sein. CSV steht für “comma-separated values”. Da diese Dateien sehr einfach gehalten sind und von einer großen Bandbreite an Software verarbeitet werden können, ist CSV eines der meistgenutzten Formate für zweidimensionale Datenstrukturen. Hier fehlt der Platz um ins Detail zu gehen, aber wir können kurz die Grundstruktur einer CSV Datei betrachten: column1, column2, column3 data1_1, data1_2, data1_3 data2_1, data2_2, data2_3 data3_1, data3_2, data3_3 Die Zeilen einer Tabelle sind durch Zeilenumbrüche getrennt, die Spalten durch Kommata. In der ersten Zeile stehen dabei häufig, aber nicht immer, die Spaltennamen. Damit wissen Sie bereits das Wichtigste. Mehr zu “.csv” Dateien finden sie unter: https://jakobtures.github.io/web-scraping/files.html Wir können beispielsweise das Ergebnis einer summarise() Operation mit write_csv() aus readr (core tidyverse) abspeichern. stammdaten_19 %&gt;% group_by(partei, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) %&gt;% ungroup() %&gt;% write_csv(file = &quot;alter_partei_titel_1.csv&quot;) ## `summarise()` has grouped output by &#39;partei&#39;. You can override using the `.groups` argument. Aus Gründen, die vermutlich nur Microsoft selbst bekannt sind – ich tippe auf missverstandene “Nutzerfreundlichkeit” –, können “.csv” Dateien, in denen die Spalten durch Kommata getrennt sind – der internationale Standard –, auf deutschen Windows Systemen nicht ohne weiteres importiert werden. Nutzen Sie statt Microsoft Office die Open Source Alternative LibreOffice, ist das Problem bereits behoben. Möchten Sie aber Microsoft Office auf einem deutschen System nutzen, sollten Sie die Datei im Deutschen Standard speichern. Dabei werden statt Kommata Semikolons als Trennzeichen der Spalten verwendet, da die Kommata in Deutschland zur Darstellung von Dezimalzahlen benötigt werden. Dies ist mit write_csv2() auf einfachem Wege möglich. 3.5.0.1 Weiterführende Resourcen Es existiert eine Vielzahl von Packages, die Funktionen zur Formatierung und dem Export von Tabellen mitbringen. Aus Platzgründen können wir nicht auf die Details eingehen, hier aber einige Startpunkte: Möchten sie direkt nach “.xlsx” exportieren, wären zwei der Optionen: writexl: https://cran.r-project.org/web/packages/writexl/index.html openxlsx: https://cran.r-project.org/web/packages/openxlsx/index.html Tabellen direkt im “.docx” Format zu erstellen ermöglicht flextable: https://davidgohel.github.io/flextable/ huxtable kann Tabellen im “.tex” Format zur Arbeit in LaTeX ausgeben: https://hughjonesd.github.io/huxtable/ Möchten sie externe Software zum Schreiben von Hausarbeiten und Papers ganz umgehen, könnte R Markdown für Sie von Interesse sein. Dies ermöglicht das gleichzeitige Schreiben von Text und Code in einem Dokument. Die Ausgabe ist unter anderem in “.pdf” möglich und kann neben dem Text auch Code, der dargettellt werden soll, sowie Tabellen und Grafiken enthalten. Einige Resourcen zu R Markdown finden Sie hier: Einführung der RStudio website: https://rmarkdown.rstudio.com/lesson-1.html{target_“blank”} Das R Markdown cheatsheet: https://raw.githubusercontent.com/rstudio/cheatsheets/master/rmarkdown.pdf Kapitel zu R Markdown in “R for Data Science” von Hadley Wickham und Garrett Grolemund: https://r4ds.had.co.nz/r-markdown.html “R Markdown Cookbook” von Yihui Xie, Christophe Dervieux, Emily Riederer: https://bookdown.org/yihui/rmarkdown-cookbook/ Die Website, die Sie aktuell betrachten, sowie viele der verlinkten Resourcen sind mit bookdown geschrieben, welches auf R Markdown aufbaut und sich vor allem für umfangreichere Projekte eignet. “bookdown: Authoring Books and Technical Documents with R Markdown” von Yihui Xie: https://bookdown.org/yihui/bookdown/ "],["R4.html", "4 Graphische Analyse mit ggplot2 4.1 ggplot2 syntax 4.2 Graphische Analyse der Stammdaten 4.3 Graphiken exportieren", " 4 Graphische Analyse mit ggplot2 Wir arbeiten in diesem Kapitel mit den in Kapitel 3 transformierten Daten weiter. Dazu müssten Sie entweder das Script aus der Vorwoche nochmals durchführen, den unten stehenden code Block, welcher alle Veränderungen an den Daten in kompakter Form enthält ausführen, oder sie laden die Daten – vorausgesetzt Sie haben sie gespeichert. Vor dem Laden der Daten müssen wir erneut das tidyverse laden. library(tidyverse) load(&quot;stammdaten.RData&quot;) stammdaten_19 &lt;- stammdaten %&gt;% filter(letzte_WP == 19) %&gt;% rename(titel = Titel, partei = Partei) %&gt;% mutate(name = str_c(nachname, vorname, sep = &quot;, &quot;)) %&gt;% mutate(titel_dummy = if_else(!is.na(titel), TRUE, FALSE)) %&gt;% mutate(partei = factor(partei)) %&gt;% mutate(partei = fct_collapse(partei, Union = c(&quot;CDU&quot;, &quot;CSU&quot;))) %&gt;% mutate(partei = fct_infreq(partei)) %&gt;% mutate(geschlecht = factor(geschlecht)) %&gt;% select(-c(nachname:titel, letzte_WP, geb)) %&gt;% relocate(name, titel_dummy, partei, geschlecht, alter, erste_WP) 4.1 ggplot2 syntax Die graphische Datenanalyse mit dem core tidyverse package ggplot2 folgt einer intuitiven Logik. Jede Grafik beginnt mit dem Initieren eines leeren plots. Diese leere “Leinwand” füllen wir dann in weiteren Schritten mit den darzustellenden graphischen Elementen. Zum Initieren des plots nutzen wir die Funktion ggplot() – auch wenn der Name des packages ggplot2 lautet, trägt der Funktionsname keine “2”. Der Funktion geben wir das Datenobjekt welches geplottet werden soll als Argument. ggplot(data = stammdaten_19) Die neu erstellte Grafik öffnet sich im “Plots” Tab von RStudio und erstrahlt in blendender Leere, da wir noch keine graphischen Elemente hinzugefügt haben. 4.1.1 geoms &amp; aesthetics Diese graphischen Element werden geoms genannt. Wir fügen Sie einem plot hinzu indem wir nach ggplot() ein + schreiben und den Befehl für das geom in der nächsten Zeile eingeben. Weitere geoms können wir auf die selbe Art und Weise hinzufügen. Die grundsätzliche Syntax – dies ist kein ausführbarer Code – sieht damit wie folgt aus: ggplot(data = ...) + geom_1() + geom_2() + ... Die geom Funktionen beginnen immer mit geom_ und enden mit einem Wort das die Art des graphischen Objekts beschreibt. Beispielsweise geom_point() für scatterplots, geom_line() für lineplots oder geom_bar() für barplots. Die aesthetics eines geoms dienen zur Zuordnung der x und y Variablen die in das Koordinatensytem geplottet werden sollen. Darüber hinaus können aesthetics auch genutzt werden um die graphische Darstellung der geplottet Elemente anhand der Werte einer weiteren Variable zu manipulieren – beispielsweise die Farbe oder Größe geplotteter Punkte oder die Dicke von Linien. Dies klingt noch sehr abstrakt, wird aber in späteren Beispielen deutlich werden. Betrachten wir zunächst, wie die Zuordnung von x und y Variablen syntaktisch funktioniert. Diese müssen festgelegt werden. Alle weiteren aesthetics sind optional. Zur Definition der aesthetics nutzen wir die Funktion aes() als ein Argument der jeweiligen geom Funktion. Innerhalb von aes() weisen wir x und y die Variablen die auf der x-Achse beziehungsweise der y-Achse abgetragen werden sollen zu. Die Syntax sieht wie folgt aus: ggplot(data = ...) + geom_1(aes(x = x_variable, y = y_variable)) + geom_2(aes(x = x_variable, y = y_variable)) + ... Nutzen wir die selben x und y Variablen für alle geoms, können wir die Zuordnung auch direkt in der Funktion ggplot() vornehmen. ggplot(data = ..., aes(x = x_variable, y = y_variable)) + geom_1() + geom_2() + ... Dies ist die grundsätzliche Syntax von ggplot2. Im Folgenden nutzen wir das package zur graphischen Analyse unserer Beispieldaten. Dabei betrachten wir nur einen Teil der verfügbaren geoms und der Möglichkeiten die Darstellung über die aesthetics und weitere Optionen zu manipluieren. Als Übersicht über alle verfügbaren geoms empfehle ich dringend das cheatsheet für ggplot2: https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-visualization.pdf Eine ausführlichere Einführung gibt das Kapitel “Data visualisation” in “R for Data Science”: https://r4ds.had.co.nz/data-visualisation.html 4.2 Graphische Analyse der Stammdaten Variablen sind kontinuierlich, wenn sie jeden Wert – möglicherweise im Minimum und Maximum begrenzt – annehmen können. Sie sind auch immer numerisch. Ein in den Sozialwissenschaften häufig anzutreffendes Beispiel für eine kontinuierliche Variable wäre das Einkommen beziehungsweise monetäre Werte im Allgemeinen, vorausgesetzt sie werden als exakter Geldwert gemessen. In unserem Beispielsdatensatz sind das Alter und die erste Wahlperiode in der ein MdB in den Bundestag eintrat kontinuierliche Variablen. Variablen sind kategorial, wenn Sie als Werte nur eine begrenzte Anzahl vordefinierter Kategorien annehmen können. Wird das Einkommen statt als exakter Wert als Mitgliedschaft in breiten Einkommensgruppen gemessen, ist dies eine kategoriale Variable. In den Beispieldaten sind die Parteimitgliedschaft, das Geschlecht sowie die Dummyvariable zum akademischen Titel kategoriale Variablen. Geoms können danach unterschieden werden, für welche Typen von x und y Variablen sie anwendbar sind. Dieser Logik folgt auch das oben verlinkte cheatsheet. 4.2.1 kontinuierliches x &amp; y Das Alter und die erste Wahlperiode in der ein MdB im Bundestag vertreten war, sind die einzigen kontinuierlichen Variablen in unserem Beispielsdatensatz. Eine Korrelation zwischen beiden Variablen ist naheliegend. Je älter ein MdB desto früher konnte er oder sie potentiell das erste mal in den Bundestag einziehen. Das Alter bei Ersteinzug in den BT wird aber zwischen den MdBs variieren. So werden wir Abgeordnete finden, die erst im relativ hohen Alter das erste Mandat erlangt haben und Andere die dabei überdurchschnittlich jung waren. Die erste Wahlperiode wird also nicht strikt vom Alter abhängen, dass ein Zusammenhang besteht scheint aber intuitiv schlüsig. Das Alter erklärt in unserer ad hoc Hypothese also den ersten Einzug in den Bundestag. Dabei müssen wir von einem negativen Zusammenhang ausgehen. Je höher das Alter, desto niedriger die Wahlperiode des ersten Einzugs. Typischerweise, wird die erklärende unabhängige Variable auf der x-Achse, die zu erklärende abhängige Variable auf der y-Achse abgetragen. Mit geom_point() können wir einen scatterplot erstellen um die Kombination der Werte für Alter und die erste Wahlperiode für jeden MdB als Punkt in einem Koordinatensystem darzustellen. ggplot(data = stammdaten_19, aes(x = alter, y = erste_WP)) + geom_point() Der plot spricht auf den ersten Blick für den angenommenen Zusammenhang zwischen Alter und erster Wahlperiode. Je weiter die erste Wahlperiode zurückliegt, desto älter sind die MdBs. So finden wir beispielsweise unter den wenigen Abgeordneten die bereits im 11. Bundestag vertreten waren nur über 60-jährige, im 12. nur über 55-jährige und so weiter. Wir sehen aber auch, dass die Altersspannweite bei den nicht so weit in der Vergangenheit liegenden Wahlperioden sehr groß ist. Sehen wir uns dies für den 19. Bundestag genauer an. stammdaten_19 %&gt;% filter(erste_WP == 19) %&gt;% summarise(minimum = min(alter), maximum = max(alter), spannweite = maximum - minimum, anzahl = n()) ## # A tibble: 1 × 4 ## minimum maximum spannweite anzahl ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 24 77 53 279 Wir sehen, dass die 279 MdBs für die der 19. Bundestag das erste Mandat darstellt, bei Einzug zwischen 24 und 77 Jahre alt waren. Eine Spannweite von 53 Jahren! Beim betrachten des plots fällt etwas weiteres auf. Wir wissen, dass wir Daten zu 732 Abgeordneten haben. Ohne die Punkte im scatterplot zu zählen, sollte deutlich sein, dass wir keine 732 Punkte sehen. Wohin sind unsere Datenpunkte verschwunden? Das Problem ist, dass beide Variablen in unserem Datensatz relativ wenig unterschiedliche Werte annehmen können. Wir haben nur eine begrenzte Anzahl möglicher erster Wahlperioden und, auch wenn hier die Menge möglicher Werte größer ist, eine absteckbare Menge an Altern die ein MdB haben kann. So wird es zur Regel statt zur Ausnahme, dass mehrere Abgeordnete die selbe Kombination beider Werte haben, also beispielsweise mehrere 50-jährige MdBs ihr erstes Mandat im 19. Bundestag hatten. Diese Punkte liegen dann alle übereinander und sind im scatterplot nicht zu unterscheiden. Sidenote: Mehr mögliche Werte – wir zum Beispiel das genaue Alter in Tagen statt gerundet auf Jahre – könnten das Problem abschwächen. Wie können wir diese übereinanderliegenden Werte sichtbar machen? ggplot2 bietet uns dazu zwei praktische geoms an. Eine Möglichkeit ist statt geom_point() die Funktion geom_count() zu verwenden. Im Unterschied zum normalen scatterplot, variieren die Punkte hier in ihrer Größe relativ zu der Anzahl Beobachtung pro Wertekombination. Je mehr Abgeordnete die selben Werte für Alter und ihr erstes Mandat haben, desto größer wird der Punkt dargestellt. ggplot(data = stammdaten_19, aes(x = alter, y = erste_WP)) + geom_count() Eine weitere Möglichkeit ist geom_jitter(). Hier werden wieder einzelne Punkte geplottet, diese werden aber zufällig leicht in x und y Richtung verschoben. Übereinanderliegende Punkte bewegen sich in der Darstellung somit auseinander. Das Problem mit dieser Form des plots ist, dass die dargestellten Punkte nicht mehr (exakt) den tatsächlichen Werten entsprechen. Die Darstellung kann trotzdem hilfreich sein um generelle Muster zu erkennen, wir müssen den Zufallsfaktor aber bei der Interpretation der Grafik mitbedenken. ggplot(data = stammdaten_19, aes(x = alter, y = erste_WP)) + geom_jitter() Beide Darstellungen zeigen uns, dass die Altersspanne in der pro Wahlperiode die Mehrzahl der Abgeordneten fallen zwar immernoch groß ist, aber deutlich kleiner als der erte scatterplot suggeriert hat. Zudem verschiebt sich dieser Schwerpunkt mit abnehmenden y langsam nach rechts, was auf den angenommenen Zusammenhang zwischen Alter und erster Wahlperiode hindeutet. Um diesen Zusammenhang zu verifizieren – oder zu falsifizieren – könnten wir eine Regressionsgerade über die geplotteten Puntke legen. Diese visualisiert den linearen Zusammenhang zwischen zwei Variablen als gerade Linie. Die Regressionsgerade wird dabei so über die Daten gelegt, dass Sie deren Zusammenhang bestmöglichst beschreibt, also die Abweichung von den tatsächlichen Daten minimiert. Um dies zu realisieren, können wir geom_smooth() nutzen. Dabei legen wir als erstes Argument method = 'lm' fest. Wir teilen der Funktion so mit, dass wir ein lineares Modell, eine lineare Regression, berechnen möchten. Das Argument se = FALSE unterdrückt die Darstellung des Konfidenzintervals – ein Maß für die Unsicherheit des geschätzten Zusammenhangs. ggplot(data = stammdaten_19, aes(x = alter, y = erste_WP)) + geom_jitter() + geom_smooth(method = &#39;lm&#39;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; Der Winkel in dem die Regressionsgerade verläuft – die slope – zeigt uns den Zusammenhang zwischen beiden Variablen an. Mit steigendem Alter nimmt also der Wert der ersten Wahlperiode ab. Dabei ist der Verlauf der Geraden aber nicht sehr steil. Die Korrelation zwischen den Variablen ist zwar da und auch deutlich, aber nicht besonders stark. Dies liegt vor allem daran, dass die überwiegende Mehrzahl der MdBs erst in einer der letzten Wahlperioden in den Bundestag eingezogen sind. Die wenigen Abgeordneten die schon seit mehr als 16–20 Jahren im Bundestag vertreten sind, sind zwar auch älter, aber zu wenige um die Regressionsgerade stärker zu beeinflussen. An der Regressionsgerade können wir auch den geschätzten Wert einer Variable gegeben dem Wert der anderen Variable ablesen. So sehen wir beispielsweise, dass die lineare Regression für einen 60-jähriger MdB schätzt, dass dieser ab der 17. Wahlperiode im Bundestag vertreten war. Weiterführende Informationen dazu, wie wir scatterplots und Regressionsgeraden nach einer dritten Variable gruppiert darstellen können, finden Sie unter: https://jakobtures.github.io/web-scraping/ggplot.html#continuous-x-continuous-y 4.2.2 kategoriales x, kontinuierliches y In Kapitel 3 haben wir mit summarise() und group_by() die Anzahl von Mandaten pro Partei berechnet. Diese könnten wir auch in einer Graphik darstellen. Die Variable zur Parteimitgliedschaft ist dabei eine kategoriale Variable, die Anzahl der Abgeordneten ist kontinuierlich, liegt aber nicht als Variable vor. Dies benötigen wir aber auch nicht, da geom_bar() – für barplots – die Anzahl von Beobachtungen pro Kategorie der x Variable automatisch berechnet. So müssen wir in den aesthetics auch nur die x Variable zuordnen. stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar() So schnell und einfach kommen wir zu einem barplot der Parteimitgliedschaft. Die Darstellung ist dabei aber nicht sonderlich hübsch. Ein Problem ist, dass das label “BÜNDNIS 90/DIE GRÜNEN” so lang ist, dass es mit dem label “DIE LINKE.” überlappt. Mit scale_x_discrete() können wir Optionen für kategoriale x-Achsen verändern. In dem Argument labels = können wir eine Liste eigener labels festlegen oder labels einzelner Kategorien verändern. stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar() + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) Optionen für die y-Achse und andere Typen von Skalen sind ebenfalls verfügbar, beispielsweise scale_y_continuous(). Innerhalb dieser Funktionen, können wir auch die Achsenlabels selbst benennen. Oder wir nutzen labs(), was neben den Achsennamen auch die Bennenung weiterer Elemente der Graphik erlaubt. Beispielsweise: stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar() + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) Soweit, so gut. Aber die Balken sind doch noch sehr eintönig grau. In der aes() Funktion innerhalb von geom_bar() oder auch ggplot(), können wir über das fill = Argument festlegen, dass die Balken nach dem Wert einer Variable eingefärbt werden sollen. Setzen wir dieses gleich der Variable “partei”, bekommt jeder Balken eine eigene Farbe zugewiesen. Die automatisch erstellte Farblegende, verstecken wir mit einem weiteren Argument. stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(aes(fill = partei), show.legend = FALSE) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) Noch schöner wäre es, wenn die Balkenfarben mit den tatsächlichen Parteifarben übereinstimmen würden. Dazu können wir die Farben der Balken per Hand festlegen statt sie automatisch zuweisen zu lassen. Hier erstellen wir einen Vektor mit Farbnamen den wir dann für das fill = Argument nutzen. Beachten Sie dabei, dass fill = diesmal nicht innerhalb von aes() steht. Dies liegt daran, dass wir die Farben nicht anhand einer Variable festlegen sondern konstant zuweisen, was außerhalb von aes() erfolgt. parteifarben &lt;- c(&quot;black&quot;, &quot;red&quot;, &quot;deepskyblue&quot;, &quot;yellow2&quot;, &quot;limegreen&quot;, &quot;violetred&quot;, &quot;grey&quot;) stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(fill = parteifarben) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) Eine Übersicht über alle verfügbaren Farben, finden Sie unter: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf Mich persönlich stört an dieser Stelle noch der graue Hintergrund des plots. Dieser ist Teil des standard themes von ggplot2, theme_gray(). Wir können aber auch andere themes auswählen. Eine Übersicht finden sie hier: https://ggplot2.tidyverse.org/reference/ggtheme.html stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(fill = parteifarben) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Nutzen wir für die fill aesthetic eine zweite Variable, beispielsweise die Informationen zu akademischen Titeln, erhalten wir einen gestapelten barplot. Hier macht es wiederum Sinn, die automatisch erstellte Farblegende nicht auszublenden. stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(aes(fill = titel_dummy)) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate mit/ohne Titel im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Möchten wir die Balken nicht stapeln sondern nebeneinander darstellen, können wir dies über das Argument position = \"dodge\" festlegen. Um die Darstellung weiter aufzuhübschen können wir außerdem den Titel der Farblegende in labs() anpassen. stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(aes(fill = titel_dummy), position = &quot;dodge&quot;) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate mit/ohne Titel im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;, fill = &quot;Akadem. Titel&quot;) + theme_minimal() 4.2.3 kontinuierliches x In Kapitel 3 haben wir deskriptive Statistiken zur Altersverteilung berechnet. Auch diese können wir graphisch darstellen. Dazu bietet sich unter anderem geom_histogram() an. Ein Histogramm unterteilt eine kontinuierliche Variable in eine festlegbare Anzahl von Abschnitten – bins – und stellt die Anzahl von Beobachtungen die in jedes bin fallen als Balken dar. Als Standard unterteilt ggplot2 eine Variable in 30 bins, dies können wir aber über das bins = Argument beeinflussen. stammdaten_19 %&gt;% ggplot(aes(x = alter)) + geom_histogram() + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Um die Grafik besser interpretierbar zu machen, könnten wir eine vertikale Linie hinzufügen die den Mittelwert der x Variable markiert. Dazu nutzen wir geom_vline() und legen für xintercept = den x Wert fest, an dem die Linie eingezeichnet werden soll. Außerdem scheint es angebracht, die Anzahl der bins zu reduzieren. Mit 30 bins, deckt jeder Balken knapp 2 Jahre ab. So werden zufällige Fluktuationen in der Altersverteilung überbetont. stammdaten_19 %&gt;% ggplot(aes(x = alter)) + geom_histogram(bins = 15) + geom_vline(aes(xintercept = mean(alter)), colour = &quot;red&quot;) + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Wir sehen, dass die Alterstruktur annäherend um den Mittelwert normalverteilt ist, die Verteilung aber leicht links-schief ist. Das bedeutet, dass die Verteilung auf der linken Seite etwas langsamer ansteigt als die auf der rechten abnimmt. Dies ist hier vor allem mit dem starken Abfall von Mandatsträgern beim Erreichen des Rentenalters erklärbar. Durch das Verringern der bins auf 15 – jeder bin deckt so 3-4 Jahre ab –, erscheint die Altersverteilung deutlich näher an einer Normalverteilung, da Fluktuationen in der Altersverteilung so weniger betont werden. Wenn es unser Ziel ist, die generelle Altersverteilung im Bundestag zu bewerten, macht dieser Ansatz aus meiner Sicht auch durchaus Sinn. Wir sollten aber davon absehen, solange an der “bins-Schraube” zu drehen, bis wir ein Bild bekommen, dass uns gefällt. Vielmehr sollten wir vor dem plotten darüber nachdenken, was das Ziel der graphischen Darstellung ist und die bins entsprechend festlegen. Möchten wir die Histogramme für alle Parteien vergleichen, können wir facets nutzen. Dabei werden in einem plot mehrere einzelne plots neben- und untereinander dargestellt. In der Funktion facet_wrap() schreiben wir dazu den Namen der Variable nachdem die Kacheln gebildet werden sollen und setzen davor eine Tilde ~. stammdaten_19 %&gt;% ggplot(aes(x = alter)) + geom_histogram(bins = 15) + facet_wrap(~ partei) + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag nach Partei&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Um dies besser interpretierbar zu machen, könnten wir die Mittelwerte des Alters für jede Partei einzeichnen. Diese müssen wir dazu zunächst pro Partei berechen. Dazu nutzen wir wiederum die dplyr Funktionen und hängen ggplot() am Ende der pipe an. In diesem Zuge, können wir auch die Parteilosen herausfiltern, da ihre Anzahl für eine inhaltliche Interpretation deutlich zu klein ist. stammdaten_19 %&gt;% filter(partei != &quot;Plos&quot;) %&gt;% group_by(partei) %&gt;% mutate(arith_mittel = mean(alter)) %&gt;% ungroup() %&gt;% ggplot(aes(x = alter)) + geom_histogram(bins = 15) + geom_vline(aes(xintercept = arith_mittel), colour = &quot;red&quot;) + facet_wrap(~ partei) + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag nach Partei&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Die Befunde aus Kapitel 3 lassen sich zunächst bestätigen. Der relativ hohe Mittelwert der AfD wird durch viele besonders alte Mandatsträger:innen etwas nach oben verschoben. Keine andere Partei hat so “viele” – es geht hier eigentlich um eine geringe Anzahl von Personen – Abgeordnete über 70. FDP und GRÜNE als die im Mittelwert jüngsten Parteien unterscheiden sich in Ihrer Altersspannweite. Die FDP hat viele sehr junge aber auch sehr alte MdBs, während die Spannweite bei den Grünen deutlich enger ist. Wir erkennen nun auch, dass die Altersverteilung in der Union relativ nahe an der generellen Altersverteilung des 19. Bundestags liegt. Interessant sind die Verteilungen von SPD und von DIE LINKE. Anders als die alleinige Betrachtung des Mittelwerts suggeriert, liegt der Schwerpunkt der Altersverteilung in beiden Parteien bei den über 50-jährigen. Es gilt zu erinnern, dass die Histogramme für die kleineren Parteien auf wenig Fällen basieren. Die Fluktuationen zwischen den bins sollten deshalb nicht überinterpretiert werden. Eine Alternative zu Histogrammen sind density plots. Diese können wir als geglätte Version eines Histogramms verstehen. Statt abgesteckter bins für die jeweils die Anzahl Beobachtungen die in dieses Interval der x Variable fallen exakt gezählt werden, wird bei einem density plot die “Dichte” der Daten über alle x Werte hinweg geschätzt. Diese Dichte wird auf der y-Achse abgetragen und summiert sich zu 1 auf. Dabei werden Fluktuationen in der Verteilung weniger detailliert abgebildet, aber wie bekommen dafür ein klareres Bild der generellen Verteilung einer kontinuierlichen Variable. Zwei weitere Vorteile sind, dass wir für density plots keine Entscheidungen zur Größe beziehungsweise Anzahl der bins treffen müssen und diese sich besser zum übereinanderlegen eignen als Histogramme. So könnten wir beispielsweise die in Kapitel 3 bereits angesprochene Altersverteilung für Träger akademischer Titel und Personen ohne einen Titel in zwei übereinandergelegten density plots gleichzeitig betrachten und vergleichen. Dazu plotten wir mit geom_density() und nutzen entweder die fill oder colour aesthetic. Bei fill wird die Fläche unter der Kurve gefüllt, bei colour werden nur die Kurven farblich gezeichnet. stammdaten_19 %&gt;% ggplot(aes(x = alter, colour = titel_dummy)) + geom_density() + labs(x = &quot;Alter&quot;, y = &quot;Density&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;, colour = &quot;Akadem. Titel&quot;) + theme_minimal() Beide Verteilungen sind sich relativ ähnlich, bei den Titelträgern gibt es aber einen höheren Anteil besonders alter MdBs. Wir haben auch bereits gesehen, dass es möglicherweise Unterschiede zwischen den Parteien gibt. Diese können wir erneut mit einem facet vergleichen. Dazu filtern wir zunächst die Parteilosen heraus, da durch ihre geringe Anzahl nicht genug Daten zur Verfügung stehen um belastbare Ergebnisse zur Verteilung zu berechnen. stammdaten_19 %&gt;% filter(partei != &quot;Plos&quot;) %&gt;% ggplot(aes(x = alter, colour = titel_dummy)) + geom_density() + facet_wrap(~ partei) + labs(x = &quot;Alter&quot;, y = &quot;Density&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;, colour = &quot;Akadem. Titel&quot;) + theme_minimal() Die plots bestätigen die Ergebnisse aus Kapitel 3 weitestgehend. Union und SPD Mandatsträger mit und ohne Titel sind in der Altersverteilung sehr ähnlich. In AfD und LINKE sind Träger akademischer Titel klar älter. Bei den GRÜNEN klar jünger. Bei der FDP ist das Bild etwas differenzierter. Während Mandatsträger ohne Titel vor allem unter den jüngeren zu finden sind, ist die Alterverteilung bei Titelträgern relativ gleich über alle Alter hinweg. 4.3 Graphiken exportieren Nachdem wir nun einige schöne Graphiken erstellt haben, folgt die Frage, wie wie diese in unsere Papers und Hausarbeiten einbinden können. Arbeiten wir in R Markdown, können wir direkt den ggplot2 output nutzen, arbeiten wir aber in externer Software – z. B. Word oder LaTeX – müssen wir die Graphiken exportieren. Ein einfacher Weg ist die Funktion ggsave(). Um die letzte erstelle Graphik abzuspeichern, müssen wir ggsave() nur einen Dateinamen beziehungsweise Pfad als Argument mitgeben. Das Format der Graphik legen wir dabei einfach über die Dateiendung fest. Ich empfehle generell eine Vektorgraphik zu nutzen – beispielsweise “.eps” oder “.svg”. Der Vorteil ist, dass diese stufenlos skalierbar sind. Wir können die Größe der Graphik beim Import also in beide Richtungen anpassen, ohne dass die Darstellungsqualität leidet. Pixelbasierte Formate wie “.jpeg” oder “.png” sind bereits komprimiert und verlieren dadruch an Qualität. Möchten wir diese vergrößern, wird die Darstellung zunehmend verschwommen. Das Verkleinern funktioniert eventuell besser, kann aber auch graphische Artefakte erzeugen. Hier speichern wir die letzte erstellte Graphik – die density plots nach Parteien – als “.eps”. ggsave(&quot;age_density_by_party.eps&quot;) ## Saving 7 x 5 in image Flexibler einsetzen lässt sich sich ggsave(), wenn wir plots zunächst einem Objekt zuweisen. So ist es nicht mehr notwendig direkt nach der Erstellung einer Graphik den Export vorzunehmen. Hier erstellen wir zwei Graphiken und weisen diese zunächst Objekten zu um sie später abzuspeichern. Durch die Objektzuweisung bekommen wir dabei keinen output. Ich würde empfehlen zunächst die Graphik zu gestalten bis das Endergbnis erreicht ist und die Objektzuweisung erst dann hinzuzufügen. Die erstellten Graphiken exportieren wir am Ende des Blocks. Dabei handelt es sich um den barplot der Abgeordneten nach Parteien. Einmal wie oben als Version mit den Parteifarben, einmal als greyscale Variante, welche sich besser zum Druck eignet. Dazu fügen wir scale_fill_grey() hinzu. mdb_partei_colour &lt;- stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(fill = parteifarben) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() mdb_partei_grey &lt;- stammdaten_19 %&gt;% ggplot(aes(x = partei)) + geom_bar(aes(fill = partei)) + scale_x_discrete(labels = c(&quot;BÜNDNIS 90/DIE GRÜNEN&quot; = &quot;DIE GRÜNEN&quot;)) + labs(x = &quot;Partei&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Parteizugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + scale_fill_grey() ggsave(&quot;mdb_party_colour.eps&quot;, plot = mdb_partei_colour) ## Saving 7 x 5 in image ggsave(&quot;mdb_party_grey.eps&quot;, plot = mdb_partei_grey) ## Saving 7 x 5 in image Wir können für ggsave() noch weitere Argumente festlegen. Zum Beispiel um die Größe und Auflösung der Graphik einzustellen. Diese sind vor allem interessant, wenn wir uns für das Speichern in einem pixelbasierten Format entscheiden. Für mehr Informationen betrachten Sie bitte ?ggsave(). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
