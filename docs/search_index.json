[["index.html", "Quantitative Textanalyse mit R Einleitung Quantitative Textanalyse Kursinhalte Konventionen Danksagung Colophon", " Quantitative Textanalyse mit R Jakob Tures 2021-09-10 Einleitung Quantitative Textanalyse Quantitative Textanalyse umfasst die Anwendung statistischer Methoden auf – in erster Linie – geschriebene Sprache. Darunter fallen unter anderem das einfache Zählen von Worthäufigkeiten, die Analyse von Korrelationen und Netzwerken zwischen Wörtern, das Erkennen der emotionalen Haltung in geschriebener Sprache und die automatisierte Einordnung von Texten in latente oder explizite Kategorien. Diese und andere Techniken der quantiativen Textanalyse werden wir in diesem Kurs behandeln. Texte als Datenbasis empirischer Wissenschaft kommen vor allem in der qualitativen Forschung zum Einsatz. Hier werden Texte “per Hand” nach Ihren Bedutungsinhalten kodiert oder kategorisiert. Dies hat den Vorteil, dass Sprache in ihrem Kontext und ihrer enormen Komplexität von Menschen verstanden wird und Ebenen analysiert werden können die tiefer liegen als das reine geschriebene Wort es ausdrücken könnte. In der quantitativen Textanalyse nutzen wir hingegen vor allem computergestützte Methoden. Computer können menschliche Sprache jedoch nicht in dem Sinne verstehen, wie eine menschliche Kodierer:in dies kann. Möchten wir beispielsweise den emotionalen Gehalt eines Textes – das sentiment – analysieren, können wir ein dictionary mit nach Emotionen kodierten Wörtern an unsere Textdaten anlegen, die Relation von “positiven” und “negativen” Wörtern berechnen und Aussagen zu dem durchschnittlichen sentiment eines Textes treffen. Da bei diesen relativ einfachen Techniken in der Regel nur einzelne Wörter für sich betrachtet werden, kann der Computer bereits Probleme mit der Verneinung von Begriffen haben. “Nicht gut” können wir als Menschen sofort als negativ verstehen während unsere Software “nicht” und “gut” getrennt betrachtet und so im besten Fall ein neutrales, im schlimmsten Fall ein positives sentiment erkennt. Noch schwieriger wird es Ironie, Humor, Anspielungen usw. adäquat mit den Mitteln der quantitiven Analyse zu erfassen, eine Aufgabe die vor allem in der geschriebenen Sprache bereits für Menschen schwierig sein kann – vermutlich kennt jeder von uns die Situation, das sentiment von Textnachrichten falsch ausgelegt zu haben. Auch bei der Anwendung der ausgfeilteren Methoden quantitativer Textanalyse müssen wir uns dieser Beschränkungen stets bewusst sein. Unsere Techniken und Algorithmen werden die Fähigkeit menschlicher Kodierer:innen Sprache in ihrem Kontext zu verstehen nicht erreichen. Somit drängt sich natürlich die Frage zwingend auf, warum sollten wir überhaupt Sprache computergestützt analysieren? Auch wenn wir die beschriebenen Einschränkungen nicht “wegrationalisieren” können, bringt die quantiative Textanalyse auch enorme Vorteile mit sich. Zunächst steht uns ein umfangreicher Werkzeugkoffer voller hochentwickelter Methoden zur Verfügung um zum Einen den Fehler gering zu halten und diesen zum Anderen quantifizierbar zu machen. Auch überlassen wir den Computer in der Textanalyse nicht sich selbst, sondern treffen bewusste Entscheidungen in der Gestaltung der Analyse und interpretieren die Ergebnisse im Bewusstsein der Komplexität von Sprache und der Grenzen unserer Methoden mit kritischem Blick. Wir können also mit den Einschränkungen der Methode bewusst und möglichst objektiv umgehen, dies ist aber weiterhin noch kein Argument für die quantitative Textanalyse. Was diese aber im Gegensatz zu qualitativer Textanalyse möglich macht, ist die Analyse großer Datenmengen in kurzer Zeit. Menschliches Kodieren von Texten ist sehr zeitaufwendig und beschränkt sich in der Regel auf eine geringe Anzahl von Dokumenten. In der computergestützten Textanalyse können wir hingegen enorm große Textmengen in relativ wenig Zeit analysieren. Wenn ein sehr großes Analyseprojekt mit aufwendigen Algorithmen mehrere Stunden Rechenzeit in Anspruch nimmt – diese Größenordnung werden wir in disem Kurs nicht erreichen – steht dies im Verhältnis zu mehreren Jahren Arbeitszeit menschlicher Kodierer:innen. Im Rahmen dieses Kurses werden wir die Plenarprotokolle des 19. Deutschen Bundestags analysieren. Dies sind mehr als 200 Protokolle mit jeweils bis zu mehreren hundert Seiten Text. Diese per Hand zu analysieren ist mehr oder weniger unmöglich. Computergestützt wird aus “unmöglich” jedoch nicht nur “machbar”, sondern wir können uns während der Rechenzeit sogar noch einen Kaffee holen. Ein weiteres starkes Argument für quantitative Textanalyse ist aus meiner Sicht die Nachvollziehbarkeit und Transparenz der Analyse. Jede Nutzer:in mit Zugang zu den Daten und unserem R-scripts kann die Analyse replizieren oder auch modifizieren. Diese Replizierbarkeit ist eine fundamentale Säule empirischer Wissenschaft und unabhängig von der nicht in Frage gestellten Fähigkeit und Gründlichkeit qualitativer Forscher:innen dort in dieser Form nicht möglich. Eine letzte einleitende Bemerkung: Auch wenn ich in den obrigen zeilen viele Vergleiche zur qualitativen Textanalyse – der klassischen “Heimat” von Textanalysen – gezogen habe, möchte ich klar betonen, dass es mir weder um eine Aufwertung des einen noch um eine Abwertung des anderen Ansatzes geht. Qualitative Methoden eröffnen Fragestellungen die den quantitativen verschlossen bleiben und andersherum. Die relevante Frage ist also nicht, welcher Ansatz ist “besser”, sondern welcher ist adäquat für mein Forschungsinteresse? Beispiele Kursinhalte Der erste Block des Kurses (Kapitel 1, 2, 3 &amp; 4) umfasst eine Einführung in R und RStudio. R ist eine Programmiersprache die vor allem für statistische Analysen Anwendung findet. Die Grundfunktionen von R können durch das Einbinden von professionellen und nutzergeschriebenen packages erweitert werden. Diese Erweiterungen sind es, die R so flexibel machen und neben statistischen Analysen unter anderem auch das Schreiben von Websites direkt in R – so wie diese Website – und die Aufbereitung und Analyse von Textdaten ermöglichen. RStudio ist ein IDE – integrated development environment – für R und vereinfacht das Arbeiten mit der Sprache. Der erste Block umfasst Informationen zur Installation beider Softwares, der Bedienung von RStudio sowie grundlegenden R Befehlen. Abgeschlossen wird er mit einem Überblick zur Transformation von Daten und deren graphischer Analyse mit dem verbreiteten R package tidyverse. Kapitel 5 befasst sich mit dem Datensatz der im Kurs zur Textanalyse verwendet wird, den Plenarprotokollen des 19. Deutschen Bundestags. Wir betrachten den Inhalt des Datensatzes sowie dessen Struktur. Im dritten Block (Kapitel 6, 7, 8 &amp; 9) beginnt die eigentliche Textanalyse. Wir nutzen dazu das tidytext package, welches nach der Logik des tidyverse funktioniert und sich somit sehr gut in dessen datenanalytischen workflow integriert. Wir beginnen mit dem Umgang mit Textdaten und der statistischen Analyse einzelner Wörter bevor wir uns der Arbeit mit Wortkombinationen widmen. Abgeschlossen wird der Block mit Techniken zur sentiment Analyse anhand eines dictionaries. Block Vier (Kapitel 10, 11 &amp; 12) führt ein weiteres package zur quantitativen Textanalyse ein, quanteda. Dieses nutzt eine alternative Struktur für Textdaten, deren Prinzipien wir beleuchten und uns damit auseinandersetzen, wie wir sie mit dme tidyverse integrieren können. Im Weiteren befassen wir uns mit grundlegenden Textanalyse Techniken in quanteda und vor allem mit Methoden die über die Möglichkeiten von tidytext hinausgehen. Der abschließenden fünften Block (Kapitel 13 &amp; 14) führt in die Techniken des machine learnings ein. Wir betrachten wie wir unsupervised machine learning nutzen können um latente Dimensionen in unkategorisierten Textdaten zu erkennen und diese automatisch nach Gemeinsamkeiten und Unterschiedenen zu gruppieren. Im supervised machine learning geben wir für einen Teil der Daten Kategorien vor um mit dem so trainierten Modell neue ungesehene Daten zu kategorieseren. Dabei gehen wir auch auf die Unterschiede und potentiellen anwendungsfälle beider Ansätze ein. Konventionen Die R Welt ist eine englischssprachige Welt. Die Namen von packages und Funktionen sind meist mehr oder weniger sprechend und stets Englisch. Auch sind die meisten Begriffe die sich auf R und RStudio beziehen englischsprachig. Sinnvolle Übersetzungen existieren meist nicht. Auch wäre es nicht zielführend diese Begriffe selbst zu übersetzen da dies nur unnötig verwirren würde. Einer der wichtigsten Skills die Sie im Umgang mit einer Sprache wie R entwickeln müssen, ist das gezielte googlen nach Problemen bzw. Lösungen. Dazu benötigen Sie das englischsprachige Fachvokabular. Dies alles spräche dafür diese Einführung in Englisch zu verfassen. Da aber das Datennmaterial, die Plenarprotokolle, Deutsche Texte sind, blieb als Option nur der Kompromiss die Seite auf Deutsch zu schreiben und die englischsprachigen Fachbegriffe einzubinden ohne sie zu übersetzen. Die Namen von R packages werden fett geschrieben. Da R case sensitive, also Groß- und Kleinschreibung nicht beliebig austauschbar ist, werden die Namen der packages exakt so geschrieben, wie sie benannt sind. Ein Beispiel ist: tidytext Alle Codebeispiele sind in code font gesetzt. Teilweise im Text: print(\"Hello World\"), teilweise als code block: print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; Der output des R codes wird direkt innerhalb des code blocks hinter ## gedruckt. Ich empfehle dringend den Inhalt der code blocks selbst in RStudio laufen zu lassen und den code dabei auch selbst zu tippen statt ihn zu kopieren. Um eine Sprache wir R zu erlernen, muss man sie regelmäßig selbst tippen. Nur so können die Namen häufig genutzter Funktionen sowie die R syntax in Ihr “muscle memory” übergehen. Danksagung Besonderer Dank gilt Lukas Höttges für die Unterstützung bei der Erstellung dieser Website und der Durchführung des korrespondierenden Seminars an der Universität Potsdam im Wintersemester 2021/22. Gleichermaßen danke ich den aktuellen und ehemaligen Teammitgliedern des Lehrstuhls für Methoden der empirischen Sozialforschung an der Universität Potsdam für ihr wertvolles Feedback zu technischen und inhaltlichen Fragen in diversen Kaffeepausen und Zoom-Gesprächen. Dank gilt auch den Erstellern der diversen genutzten R packages, insbesondere bookdown, tidyverse, tidytext und quanteda sowie der gesamten R community. Colophon Bei der Gestaltung dieser website sowie der vorgestellten code Beispiele kam Folgendes zum Einsatz: sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.1 (2021-08-10) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Europe/Berlin ## date 2021-09-08 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.1.1) ## backports 1.2.1 2020-12-09 [1] CRAN (R 4.1.1) ## bookdown * 0.23 2021-08-13 [1] CRAN (R 4.1.1) ## broom 0.7.9 2021-07-27 [1] CRAN (R 4.1.1) ## bslib 0.2.5.1 2021-05-18 [1] CRAN (R 4.1.1) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.1.1) ## cli 3.0.1 2021-07-17 [1] CRAN (R 4.1.1) ## codetools 0.2-18 2020-11-04 [4] CRAN (R 4.0.3) ## colorspace 2.0-2 2021-06-24 [1] CRAN (R 4.1.1) ## crayon 1.4.1 2021-02-08 [1] CRAN (R 4.1.1) ## DBI 1.1.1 2021-01-15 [1] CRAN (R 4.1.1) ## dbplyr 2.1.1 2021-04-06 [1] CRAN (R 4.1.1) ## digest 0.6.27 2020-10-24 [1] CRAN (R 4.1.1) ## dplyr * 1.0.7 2021-06-18 [1] CRAN (R 4.1.1) ## ellipsis 0.3.2 2021-04-29 [1] CRAN (R 4.1.1) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.1.1) ## fansi 0.5.0 2021-05-25 [1] CRAN (R 4.1.1) ## fastmap 1.1.0 2021-01-25 [1] CRAN (R 4.1.1) ## fastmatch 1.1-3 2021-07-23 [1] CRAN (R 4.1.1) ## forcats * 0.5.1 2021-01-27 [1] CRAN (R 4.1.1) ## fs 1.5.0 2020-07-31 [1] CRAN (R 4.1.1) ## generics 0.1.0 2020-10-31 [1] CRAN (R 4.1.1) ## ggplot2 * 3.3.5 2021-06-25 [1] CRAN (R 4.1.1) ## glue 1.4.2 2020-08-27 [1] CRAN (R 4.1.1) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.1.1) ## haven 2.4.3 2021-08-04 [1] CRAN (R 4.1.1) ## hms 1.1.0 2021-05-17 [1] CRAN (R 4.1.1) ## htmltools 0.5.2 2021-08-25 [1] CRAN (R 4.1.1) ## httr 1.4.2 2020-07-20 [1] CRAN (R 4.1.1) ## janeaustenr 0.1.5 2017-06-10 [1] CRAN (R 4.1.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.1.1) ## jsonlite 1.7.2 2020-12-09 [1] CRAN (R 4.1.1) ## knitr * 1.33 2021-04-24 [1] CRAN (R 4.1.1) ## lattice 0.20-44 2021-05-02 [4] CRAN (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.1.1) ## lubridate 1.7.10 2021-02-26 [1] CRAN (R 4.1.1) ## magrittr 2.0.1 2020-11-17 [1] CRAN (R 4.1.1) ## Matrix 1.3-4 2021-06-01 [4] CRAN (R 4.1.0) ## modelr 0.1.8 2020-05-19 [1] CRAN (R 4.1.1) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.1.1) ## pillar 1.6.2 2021-07-29 [1] CRAN (R 4.1.1) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.1.1) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.1.1) ## quanteda * 3.1.0 2021-08-17 [1] CRAN (R 4.1.1) ## R6 2.5.1 2021-08-19 [1] CRAN (R 4.1.1) ## Rcpp 1.0.7 2021-07-07 [1] CRAN (R 4.1.1) ## RcppParallel 5.1.4 2021-05-04 [1] CRAN (R 4.1.1) ## readr * 2.0.1 2021-08-10 [1] CRAN (R 4.1.1) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.1.1) ## reprex 2.0.1 2021-08-05 [1] CRAN (R 4.1.1) ## rlang 0.4.11 2021-04-30 [1] CRAN (R 4.1.1) ## rmarkdown 2.10 2021-08-06 [1] CRAN (R 4.1.1) ## rstudioapi 0.13 2020-11-12 [1] CRAN (R 4.1.1) ## rvest 1.0.1 2021-07-26 [1] CRAN (R 4.1.1) ## sass 0.4.0 2021-05-12 [1] CRAN (R 4.1.1) ## scales 1.1.1 2020-05-11 [1] CRAN (R 4.1.1) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.1.1) ## SnowballC 0.7.0 2020-04-01 [1] CRAN (R 4.1.1) ## stopwords 2.2 2021-02-10 [1] CRAN (R 4.1.1) ## stringi 1.7.4 2021-08-25 [1] CRAN (R 4.1.1) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.1.1) ## tibble * 3.1.4 2021-08-25 [1] CRAN (R 4.1.1) ## tidyr * 1.1.3 2021-03-03 [1] CRAN (R 4.1.1) ## tidyselect 1.1.1 2021-04-30 [1] CRAN (R 4.1.1) ## tidytext * 0.3.1 2021-04-10 [1] CRAN (R 4.1.1) ## tidyverse * 1.3.1 2021-04-15 [1] CRAN (R 4.1.1) ## tokenizers 0.2.1 2018-03-29 [1] CRAN (R 4.1.1) ## tzdb 0.1.2 2021-07-20 [1] CRAN (R 4.1.1) ## utf8 1.2.2 2021-07-24 [1] CRAN (R 4.1.1) ## vctrs 0.3.8 2021-04-29 [1] CRAN (R 4.1.1) ## withr 2.4.2 2021-04-18 [1] CRAN (R 4.1.1) ## xfun 0.25 2021-08-06 [1] CRAN (R 4.1.1) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.1.1) ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.1.1) ## ## [1] /home/jakobtures/R/x86_64-pc-linux-gnu-library/4.1 ## [2] /usr/local/lib/R/site-library ## [3] /usr/lib/R/site-library ## [4] /usr/lib/R/library "],["R1.html", "1 R Basics 1.1 Installation 1.2 Erste Schritte 1.3 Objekte 1.4 Vektoren 1.5 Weitere Datentypen 1.6 R packages 1.7 Funktionen", " 1 R Basics 1.1 Installation In diesem Kurs werden wir mit der Sprache R in Kombination mit der IDE RStudio arbeiten. Bevor wir mit der Einführung in die grundlegende Bedienung beginnen, zunächst einige Worte zur Installation der kostenlos zugänglichen Software. 1.1.1 R R ist eine Programmiersprache die vor allem für statistische Analysen und data science angewandt wird. Generelle Informationen zu R und die ausführliche Dokumentation, finden sie unter: https://www.r-project.org/. Die aktuelleste Version von R für alle gängigen Betriebssysteme finden sich stets im CRAN, dem Comprehensive R Archive Network unter: https://cran.r-project.org/. Die Links zu den Installationsdateien finden sich im oberen Bereich der website. Falls Sie Windows nutzen, wählen Sie bitte die “base” Version. Im Falle von macOS, hängt die Wahl des Installers von der Version Ihres Betriebssystems ab. In beiden Fällen führen Sie bitte die Datei aus und Installieren Sie R in ein Verzeichnis Ihrer Wahl. Für Linux Systeme stellt CRAN Installationsanweisungen für einige der populäreren Distribution bereit. Die Code Beispiele auf dieser Website wurden mit der R Version 4.1.1 “Kick Things” erstellt und getestet. 1.1.2 RStudio R kann nun bereits ausgeführt werden, erlaubt aber nur die Nutzung einer einfachen Konsole. Um die Arbeit mit R angenehmer zu gestalten, empfiehlt sich dringend die zusätzliche Installation eines IDE – Integrated Development Environment – also einer graphischen Benutzeroberfläche. Das populärste IDE ist RStudio, zu finden unter: https://www.rstudio.com/. Unter “Download” wählen Sie bitte die kostenlose Version von “RStudio Desktop” und den passenden installer für Ihr Betriebssystem. Installieren Sie bitte zuerst R und erst danach RStudio. Starten brauchen Sie dann in Zukunft nur noch RStudio. 1.2 Erste Schritte 1.2.1 Übersicht RStudio Das RStudio interface besteht aus vier Unterbereichen. Links-unten finden Sie die “Console” sowie weitere Tabs, die Sie zu Beginn selten bis nie brauchen werden. Die console kann genutzt werden um R code einzugeben und auszuführen, mehr dazu in Kürze. Links-oben werden geöffnete R scripts angezeigt. Aktuell haben Sie noch kein script geöffnet, ab Kapitel 2 wird dort aber der überwiegende Teil unserer Arbeit stattfinden. Rechts-oben finden sich mehrere Tabs, von denen für uns vor allem das “Environment” Tab von Interesse ist. Hier werden alle Objekte gelistet die Sie in ihrem code erstellen. Auch hierzu in Kürze mehr. Rechts-unten finden Sie erneute eine Anzahl Tabs. “Files” zeigt uns die Dateistruktur unseres Rechners, “Plots” den graphischen output (siehe Kapitel 3) und “Help” die Hilfedateien zu Funktionen und packages (mehr in Kapitel 2). 1.2.2 Hello World! Nun können wir endlich damit beginnen unseren ersten R Befehl auszuführen. In diesem Kapitel, werden wir Kommandos noch ausschließlich in der console schreiben. In der untersten Zeile der console sehen Sie ein &gt; Symbol. Hinter dieser Eingabeaufforderung können wir unsere Befehle schreiben und mit “Enter” ausführen. Versuchen Sie des mit folgender Zeile: print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; Sie haben gerade ihren ersten R Befehl ausgeführt, Ihren ersten output erhalten und gleichzeitig auch Ihre erste Funktion genutzt. Mehr zu Funktionen folgt in Kapitel 2), fürs Erste genügt es aber zu wissen, dass print() alles was von den Klammern, und im Fall von Text von den Anführungszeichen innerhalb der Klammern, umfasst ist als output druckt. Der output selbst beginnt mit [1], was anzeigt, dass dies das erste und hier das Einzige Element des outputs ist. Bitte beachten Sie, dass R die auf dieser website vor dem output dargestellten ## nicht abdruckt. 1.2.3 Rechnen mit R R versteht die bekannten arithmethischen Operatoren + - * /. Sie können R also auch als übergroßen Taschenrechner nutzen. Für fortgeschrittenere Rechenoperationen steht eine Vielzahl von Funktionen zur Verfügung. Beispielsweise gibt Ihnen sqrt() die Quadratwurzel der von den Klammern umfassten Zahl als output zurück. Oben mussten wir den Text \"Hello World!\" in Anführungszeichen einfassen. Zahlen müssen hingegen ohne Anführungszeichen geschrieben werden. Potenzen bekommen wir mit der Notation x^y. Im folgenden code block finden Sie einige Beispiele, die Sie Zeile für Zeile in die console tippen und mit “Enter” ausführen können: 17 + 25 ## [1] 42 99 - 57 ## [1] 42 4 * 10.5 ## [1] 42 84 / 2 ## [1] 42 sqrt(1764) ## [1] 42 6.480741 ^ 2 ## [1] 42 1.2.4 Vergleichsoperatoren Vergleichsoperatoren können genutzt werden um zwei Werte miteinander zu vergleichen und das Ergebnis als TRUE oder FALSE im putput zu erhalten. Um zu überprüfen ob zwei Werte gleich sind, schreiben wir ==. Dabei ist zu beachten, dass ein Vergleich zweier Werte stets zwei Gleichheitszeichen voraussetzt. = hat eine andere Bedeutung! Um zu testen ob zwei Werte nicht gleich sind, können wir != nutzen, wobei das ! geneerell für nicht steht. 42 == 42 ## [1] TRUE 42 != 42 ## [1] FALSE Weitere mögliche Vergleiche sind kleiner &lt;, kleiner gleich &lt;=, größer &gt; und größer gleich &gt;=. 10 &lt; 42 ## [1] TRUE 42 &lt;= 42 ## [1] TRUE 10 &gt; 42 ## [1] FALSE 90 &gt;= 42 ## [1] TRUE 1.3 Objekte In R können wir Daten und Ergebnisse unserer Analysen in Objekten speichern. So bleiben diese im Arbeitsspeicher erhalten und können später erneut aufgerufen und weiterverwendet werden. Ein Objekt ist dabei ein frei gewählter Name dem wir Daten zuweisen. Namen müssen dabei mit einem Buchstaben beginnen und sollten nur weitere Buchstaben, Ziffern sowie die Sonderzeichen _ und . beinhalten. Verbreitete Konventionen für längere Objektnamen sind snake case – the_answer – und camel case – theAnswer. Dies ist letztlich Geschmackssache, es empfielt sich aber eine einheitliche Schreibweise zu verwenden sowie kurze aber klare Namen zu verwenden. Daten weisen wir einem Objekt mit dem assignment operator &lt;-zu. the_answer &lt;- 42 Um sich Fingerakrobatik zu ersparen, ist es sinnvoll sich frühzeitig die Tastenkombination “Alt” + “-” anzugewöhnen, die &lt;- an der aktuellen cursor Position einfügt. Die so in einem Objekt gespeicherten Daten, können wir aufrufen, indem wir den Objektnamen als Befehl schreiben. the_answer ## [1] 42 Wir können Werte in Objekten auch direkt in Berechnungen oder in Funktionen verwenden. Beachten Sie dabei, dass die Daten eines Objekts überschrieben werden, wenn wir diesem neue Daten zuweisen. the_answer &lt;- the_answer / 2 the_answer ## [1] 21 a &lt;- 17 b &lt;- 4 the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 So erstelle Objekte werden in dem “Environment” Tab (rechts-oben) gelistet. Möchten wir erstellte Objekte entfernen, können wir dazu die rm() Funktion nutzen. Dies ist zwar in der Regel nicht notwendig, kann aber hilfreich sein um versehentlich oder nut zum Test erstellte Objekte zu löschen und so den Tab etwas aufzuräumen. rm(the_answer) 1.4 Vektoren Als wir weiter oben eine Zahl einem Objekt zugewiesen haben, haben wir ohne es zu wissen bereits unseren ersten Vektor erstellt. Vektoren sind eindimensionale Datenstrukturen die mehrere Elemente enthalten können. Die Länge eines Vektors bestimmt sich dabei anhand der Anzahl seiner Elemente. So erstellt auch the_answer &lt;- 42 einen Vektor, jedoch einen Vektor der Länge 1. Möchten wir einen Vektor mit mehreren Elementen erstellen, nutzen wir dazu die Funktion c(), wobei “c” für “combine” steht. So werden alle durch Kommas getrennten Werte innerhalb der Klammern zu einem Vektor kombiniert. v &lt;- c(7, 8, 9, 10) v ## [1] 7 8 9 10 1.4.1 Subsetting Möchten wir bestimme Elemente eines Vektors abrufen, nutzen wir subsetting. Dazu schreiben wir die Position des gewünschten Elements innerhalb des Vektors als Zahl in [] direkt nach dem Objektnamen. Um beispielsweise das erste oder das dritte Element unseres Vektors abzurufen: v[1] ## [1] 7 v[3] ## [1] 9 Mehrere Elemente gleichzeitig rufen wir ab indem wir mehrere Positionen mit c() kombinieren oder wir definieren mit : eine Spannweite von Positionen. v[c(1, 3)] ## [1] 7 9 v[2:4] ## [1] 8 9 10 1.4.2 Typen von Vektoren Betrachten wir den Vektor v im environment, fällt auf, dass RStudio num [1:4] vor den gespeicherten Werten abduckt. Dies drückt zum einen aus, dass der Vektor die Länge 4 hat, zum anderen den Typ des Vektors. Hier handelt es sich um einen numerischen Vektor – numeric, ausgedrücht durch “num” – also einen Vektor der Zahlen enthält. Um Imformationen zu Typ, Länge und Inhalt von Objekten zu erhalten können wir auch die Funktion str()– structure – nutzen. Dies ist vor allem bei komplexeren Objekten wie Listen oder data frames (mehr dazu später) hilfreich um einen ersten Überblick zu erhalten ohne das komplette Objekt abzudrucken. str(v) ## num [1:4] 7 8 9 10 R kennt noch weitere Typen von Vektoren, wobei für uns vor allem die Typen logical und character von Bedeutung sind. Logical Vektoren können nur die Werte TRUE und FALSE enthalten. Diese entstehen beispielsweise wenn wir Vergleichsoperatoren für einen Test nutzen. x &lt;- c(1, 7, 3, 5) x &gt;= 5 ## [1] FALSE TRUE FALSE TRUE Wir können logische Vektoren aber auch selbst erstellen. z &lt;- c(TRUE, FALSE, TRUE) z ## [1] TRUE FALSE TRUE Character Vektoren beinhalten Zeichenfolgen, sogenannte strings. Strings müssen stets von Anführungszeichen umschlossen sein. char_v &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;character&quot;, &quot;vector!&quot;) Auch character Vektoren können miteinander verglichen werden. &quot;same&quot; == &quot;same&quot; ## [1] TRUE &quot;same&quot; == &quot;not the same&quot; ## [1] FALSE &quot;same&quot; != &quot;not the same&quot; ## [1] TRUE Da wir mit character Vektoren natürlich nicht rechnen können, kann es zu Problemen kommen wenn wir Zahlenwerte, beispielsweise als strings aus einem Text ausgelesen, als character Vektor gespeichert haben. a &lt;- c(1, 2, 3) b &lt;- c(&quot;7&quot;, &quot;8&quot;, &quot;9&quot;) str(a) ## num [1:3] 1 2 3 str(b) ## chr [1:3] &quot;7&quot; &quot;8&quot; &quot;9&quot; a + b ## Error in a + b: non-numeric argument to binary operator Wir können R aber anweisen einen character Vektor in einen numerischen Vektor umzuwandeln. a + as.numeric(b) ## [1] 8 10 12 Alle Typen von Vektoren können neben ihren nativen Inhalten auch NA enthalten, die Repräsentation von fehlenden Werten in R. c &lt;- c(1, 2, NA, 4) c ## [1] 1 2 NA 4 1.5 Weitere Datentypen 1.5.1 Data frames Data frames sind zweidimensionale Datenobjekte aus Spalten und Zeilen, also das was wir uns im Allgemeinen unter einer Tabelle vorstellen. Spalten enthalten benannte Variablen, Zeilen enthalten Beobachtungen. Um einen data frame zu erstellen nutzen wir die Funktion data.frame() und definieren innerhalb der Klammern benannte Spalten und ihre Inhalte, getrennt durch Kommas. df &lt;- data.frame(Name = c(&quot;Peter&quot;, &quot;Mary&quot;), Alter = c(42, 24), Weiblich = c(FALSE, TRUE)) df ## Name Alter Weiblich ## 1 Peter 42 FALSE ## 2 Mary 24 TRUE R erkennt dabei automatisch, welche Datentypen die Spalten enthalten. str(df) ## &#39;data.frame&#39;: 2 obs. of 3 variables: ## $ Name : chr &quot;Peter&quot; &quot;Mary&quot; ## $ Alter : num 42 24 ## $ Weiblich: logi FALSE TRUE Wir können data frames auch zuvor definierten Vektoren zusammensetzen. name &lt;- c(&quot;Peter&quot;, &quot;Mary&quot;) age &lt;- c(42, 24) female &lt;- c(FALSE, TRUE) df_2 &lt;- data.frame(Name = name, Alter = age, Weiblich = female) df_2 ## Name Alter Weiblich ## 1 Peter 42 FALSE ## 2 Mary 24 TRUE Da data frames zweidimensional sind, müssen wir beim subsetting auch eine Position für die Zeilen und Spalten angeben. Diese werden ebenfalls in [] nach dem Objektnamen eingefasst und sind durch ein Komma getrennt. Vor dem Komma steht die Position der Zeilen, nach dem Komma die Position der Spalten. Für Spalten können wir statt der Position auch den Namen der Spalte nutzen. df[1, 2] ## [1] 42 df[1, &quot;Alter&quot;] ## [1] 42 Extrahieren wir mehrere Zeilenelemente gleichzeitig, bekommen wir einen neuen data frame zurück. Um eine ganze Zeile zu extrahieren, können wir den Wert der Spaltenposition auch freilassen. Gleiches gilt für ganze Spalten, wobei wir beim subsetting einer einzelnen Spalte einen Vektor als output bekommen, bei mehreren erneut einen data frame. df[1, 2:3] ## Alter Weiblich ## 1 42 FALSE df[1, ] ## Name Alter Weiblich ## 1 Peter 42 FALSE df[, &quot;Alter&quot;] ## [1] 42 24 df[, c(&quot;Alter&quot;, &quot;Weiblich&quot;)] ## Alter Weiblich ## 1 42 FALSE ## 2 24 TRUE 1.5.2 Listen Vektoren und Spalten von data frames können immer nur Daten eines Typs enthalten. Mischen wir Datentypen, werden diese auf den kleinsten gemeinsamen Nenner gebracht. Logische Werte können auch numerisch abgebildet werden, da TRUE dem Wert 1 entspricht, FALSE dem Wert 0. In letzter Instanz können alle Datentypen als character Vektoren gespeichert werden. log_vector &lt;- c(24, TRUE) str(log_vector) ## num [1:2] 24 1 char_vector &lt;- c(&quot;Mary&quot;, 24, TRUE) str(char_vector) ## chr [1:3] &quot;Mary&quot; &quot;24&quot; &quot;TRUE&quot; Möchten wir Datentypen mischen, können wir stattdessen Listen nutzen, welche unterschiedliche Datentypen enthalten können. l &lt;-list(&quot;Mary&quot;, 24, TRUE) str(l) ## List of 3 ## $ : chr &quot;Mary&quot; ## $ : num 24 ## $ : logi TRUE Um Listen wieder aufzulösen, nutzen wir unlist(). unlist(l) ## [1] &quot;Mary&quot; &quot;24&quot; &quot;TRUE&quot; Listen können sogar andere Listen enthalten und sind so das flexibelste Datenobjekt das R bereitstellt. Beim subsetting von Listen ist darauf zu achten, dass [] immer auch eine Liste zurückgibt, selbst wenn diese nur noch ein Element enthält. Direkten Zugang zu Elementen erhalten wir mit [[]]. str(l[1]) ## List of 1 ## $ : chr &quot;Mary&quot; str(l[[1]]) ## chr &quot;Mary&quot; 1.6 R packages Die R Welt ist offen und kollaborativ. Neben den base R packages die in der Grundinstallation bereits enthalten waren, steht eine stetig steigende Zahl von nutzergeschriebenen packages zum Download zur Verfügung. Diese packages haben stets einen thematischen Fokus – beispielsweise Datenbereinigung, graphische Analyse oder Textanalyse – und enthalten eine Reihe von Funktionen die den Einsatzbereich von R über das hinaus erweitern was von den Originalentwicklern geplant war oder die etwas zu kompliziert gestaltete base R Ansätze durch neue anwenderfreundlichere Funktionen ersetzen. Packages, ihre Dokumentation und weitere Informationen werden auf CRAN – “Comprehensive R Archive Network” – gehostet. Hier haben Sie auch bereits die Installationsdateien für R heruntergeladen. Wenn Sie gleich ein package direkt aus RStudio installieren, greift die software auf CRAN zu um die erforderlichen Dateien herunterzuladen. 1.6.1 Installieren und Laden Packages installieren wir mit der R Funktion install.packages(), mit dem Namen des packages in \"\" zwischen den Klammern der Funktion. Wir werden im Verlaufe des Seminars eine Reihe von packages nutzen, darunter das tidyverse. Zur Installation des core tidyverse packages schreiben wir in der console: install.packages(&quot;tidyverse&quot;) R wird während der Installation eine lange Reihe von Informationen ausgeben, von denen uns solange alles gut geht nur das DONE (tidyverse) interessieren muss. Nach erfolgreicher Installation, können wir das Paket laden. Dies sollte normalerweise in den ersten Zeilen eines scripts passieren. So werden alle notwendigen packages zu Beginn eines scripts geladen und andere Nutzer*innen sehen sofort welche packages eventuell noch nachinstalliert werden müssen. Ein package laden wir mit library() mit dem Namen des packages innerhalb der Klammern, hier ausnahmsweise ohne \"\". library(tidyverse) Manche Pakete, wie das tidyverse, geben uns auch beim Laden eine Reihe von Informationen die wir im weiteren Verlauf des Kapitels noch genauer betrachten werden. Andere Pakete laden aber auch still, ohne Informationen in die console zu schreiben. Sollte beim laden eines packages ein Problem auftauchen, wird R dies rückmelden. 1.7 Funktionen Bis zu diesem Punkt haben wir bereits eine Reihe von Funktionen genutzt, ohne eigentlich zu Wissen, was Funktionen sind. Die in base R und den diversen packages enthaltenen Funktionen bieten einen einfachen Zugang zu komplexeren im Hintergrund ablaufenden Operationen. Statt beispielsweise eine komplizierte Datenanalysetechnik selbst zu implementieren, also jeden Rechenschritt Zeile für Zeile selbst zu schreiben, instalieren wir ein package mit einer passenden Funktion und sparen eventuell mehrere hundert Zeilen code ein. Außerdem sind die Rechnoperationen in den packages meist sehr viel effizienter geschrieben als wir ohne erweiterte Programmierkenntnisse dazu in der Lage wären. Um eine Funktion aufzurufen – im Englischen “to call a function” – schreiben wir dessen Namen gefolgt von öffnenden und schließenden Klammern. Innerhalb der Klammern geben wir ein oder mehrere Argumente an die Funktion weiter. In vielen Fällen, wird als erstes oder eniziges Argument ein Datenobjekt – oder rohe Daten – angegeben, auf das die Funktion angewandt werden soll. So “druckt” beispielsweise die base R Funktion print() die angegebenen Daten in die console, wie bereits bei print(\"Hello World!\") gesehen. Weitere Beispiele für Funktionen sind einige der in base R enthaltenen Methoden statistischen Maßzahlen zu berechnen. Legen wir zunächst einen numerischen Vektor mit einigen Beispieldaten an: data &lt;- c(4, 8, 15, 16, 23, 42) Unsere Interesse sei es das arithmetische Mittel, den Median sowie die Standardabweichung der Daten zu berechnen. Dazu können wir die Funktionen mean(), median() und sd() aus base R nutzen. Allen drei Funktionen geben wir als einziges Argument die zuvor in einem Objekt gespeicherten Daten weiter. Weitere Argumente sind zwar möglich, für dieses Beispiel aber nicht notwendig. mean(data) ## [1] 18 median(data) ## [1] 15.5 sd(data) ## [1] 13.49074 Funktionen erlauben häufig mehrere Argumente von denen einige optional sein können und es beispielsweise ermöglichen bestimmte Optionen einer Funktion zu verändern. Dies wird uns im weiteren Verlauf regelmäßig begegenen. 1.7.1 namesspaces Betrachten wir nochmals den output nach dem Laden von tidyverse weiter oben. R gibt uns neben den Namen und Versionen der geladenen packages – das core tidyverse package welches wir geladen haben ist eigentlich eine Sammlung von packages – auch die Information über zwei Konflikte aus. Konflikte entstehen, wenn zwei geladene packages Funktionen mit den selben Namen enthalten. Die Funktion aus dem später geladenen package überschreibt dabei die zuvor geladene Funktion. Hier überschreibt das tidyverse package dplyrdie Funktionen filter() und lag() aus dem base R package stats. Ohne dplyr bzw. tidyverse zu laden wäre beim aufruf von filter() die Funktion aus dem stats package genutzt worden. Nun wird die gleichnamige Funktion aus dplyr angewandt. Möchten wir zwar dplyr laden, aber die Funktion filter() aus stats nutzen, können wir den namespace der Funktion explizit angeben. Der namespace gibt R an, in welchem package es nach der Funktion suchen soll. Geben wir nur den Funktionsnamen an, sucht R in den Funktionen die aktuell geladen sind. Da filter() aus dplyr die Funktion aus stats überschrieben hat, würde erstere angewandt. Deklarieren wir den namespace, können wir R genau angeben in welchem geladenen oder ungeladenen package die Funktion zu finden ist. Dazu nutzen wir die Notation namespace::function. Um also filter() aus stats zu nutzen, schreiben wir: stats::filter(). "],["R2.html", "2 RStudio &amp; das tidyverse 2.1 RStudio workflow 2.2 tidyverse 2.3 Hilfe?", " 2 RStudio &amp; das tidyverse 2.1 RStudio workflow Im vorangegangen Kapitel haben wir unsere Befehle direkt in die R console eingegeben, mit “Enter” bestätigt und unseren output zurückbekommen. Dies funktioniert, ist aber auf lange Sicht nicht zuriedenstellend. Das Hauptproblem besteht darin, dass unser code nach dem Ausführen nicht erhalten bleibt. Wir können zwar durch die console scrollen um nachzuvollziehen, welche Befehle wir genutzt haben, dies ist uns aber spätestens nach dem Schließen von RStudio nicht mehr zugänglich. In der Realität werden Sie aber häufig längere Zeiträume an einem Projket arbeiten und möchten eventuell ihren code mit Kommiliton:innen, Kolleg:innen oder der R community teilen. Je komplexer unser code wird, desto mehr Fehler werden wir auch machen. Ein früher Fehler in der console der erst spät auffällt, kann bedeuten, dass der Großteil unserer Arbeit wiederholt werden müsste. Dies sind einige der Argumente die dafür sprechen, mit R scripts statt direkt in der console zu arbeiten. 2.1.1 R scripts Ein R script ist eine Datei in der wir unsere Befehle niederschreiben und so für die spätere Weiterarbeit und Weitergabe dokumentieren. Um ein neues R script zu erstellen klicken Sie auf “File” &gt; “New File” &gt; “R Script”, oder nutzen Sie die praktische Tastenkombination “CTRL” + “Shift” + “N”. So wird ein leeres und unbenanntes neues script erstellt. Als erste Übung können wir ein Stück code aus dem vorangegangenen Kapitel statt in der console in unser R script eingeben. a &lt;- 17 b &lt;- 4 the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 Zur Erinnerung, wir erstellen zwei numerische Objekte a und b, weisen das Ergebnis einer Berechnung mit diesen zwei Objekten einem neuem Objekt the_answer zu und lassen uns dieses Objekt, also das Ergebnis der Berechnung, ausgeben. Statt die Befehle Zeile für Zeile in die console einzugeben und jede Zeile direkt auszuführen, schreiben wir zunächst den kompletten code block in unser neues script. Danach können wir unser komplettes script durch einen Klick auf “Source” in der toolbar des script Fensters ausführen. Ich empfehle Ihnen stattdessen aber scripts stets Befehl für Befehl auszuführen. So haben Sie die volle Kontrolle über den Prozess, sehen sofort das Ergebnis (oder den Fehler) jedes einzelnen Befehls und können die Ausführung an jeder beliebigen Stelle pausieren, zum Beispiel um den Code besser nachzuvollziehen, Fehler zu erkennen oder Veränderungen vorzunehmen. Umsetzen könenn Sie dies mit einem Klick auf “Run” in der toolbar des script Fensters oder noch einfacher durch das Drücken von “CTRL” + “Enter”. In beiden Fällen wird die Zeile in der sich aktuell Ihr cursor befindet ausgeführt. Dieser springt daraufhin automatisch in die nächste Zeile, so dass sie auch Befehl für Befehl schnell ihr ganzes script ausführen können, dabei aber die volle Kontrolle behalten. Was für Sie praktikabler ist, müssen Sie selbst entscheiden und kann auch von der Situation abhängen. Bedenken Sie aber immer, dass R zu jeden Zeitpunkt davon ausgeht, dass Sie wissen was Sie tun. Es wird keine Warnmeldungen geben, wenn Sie etwas überschreiben das Sie eigentlich nicht überschreiben wollten. Sie sollten ihr script regelmäßig abspeichern. Nicht nur dann wenn Sie eine Arbeitssession beenden, sondern regelmäßig. Dies können sie über “File” &gt; “Save” erreichen oder durch die Tastenkombination “CTRL” + “S”. Sie können den Namen des scripts frei wählen, die Endung muss jedoch immer “.R” sein. Ein Problem, dass Ihnen früher oder später begegnen wird, ist dass Sie versehentlich versuchen werden inkompletten code aus einem script auszuführen. Der Grund ist sehr häufig eine fehlende schließende Klammer, wie in print(\"Hello World\". R kann den code nicht interpretieren und geht aufgrund der fehlenden Klammer davon aus, dass der code noch weitergehen soll. R übernimmt dann den inkompletten code in die console, führt ihn aber nicht aus sondern beginnt eine neue Zeile mit einem +. Dies bedeutet, dass wir hinter dem + den code fortsetzen können. In der Regel ist es am praktikabelsten die Ausführung des codes abzubrechen indem sie in die console klicken und danach “Esc” drücken. Dann können wir den code in unserem script korrigieren und erenut ausführen. 2.1.2 Projekte Häufig werden unsere R Vorhaben aus mehreren Dateien – wie scripts, Datensätzen oder ausgegebenen Graphiken – bestehen. Es macht dann häufig Sinn, diese Dateien an einem gemeinsamen Ort abzuspeichern. Dies können wir natürlich “per Hand” managen, hier aber kann RStudio’s Projektfunktion sehr hilfreich sein. Durch Klicken auf “File” &gt; “New Project”, erstellen wir ein neues Projekt. Haben wir bereits einen Ordner für das Projekt angelegt, können wir auf “Existing Directory” klicken, den Ordner auswählen und die Erstellung mit “Create Project” abschließen. Oder wir erstellen mit “New Directory” &gt; “New Project” einen neuen Ordner für das Projekt direkt aus RStudio. RStudio wird nun alle aktuell geöffneten Dateien schließen und in das neu erstellte Projekt wechseln. Der Name des gewählten oder erstellten Ordners ist auch gleichzeitig der Name des Projekts, angezeigt in der Titelleiste von RStudio. Der “Files” tab (rechts-unten) zeigt nun auch den Inhalt des Projektordners. Dies ist ihr aktuelles working directory, mehr dazu gleich. Sie können nun Dateien erstellen und bearbeiten und speichern diese ganz normal ab. Das Projekt selbst muss nie gespeichert werden. Möchten Sie in einer späteren R session ihre Arbeit an dem Projekt fortsetzen, klicken Sie auf “File” &gt; “Open Project”. Das Projekt wird geöffnet, alle Dateien die Sie bei der letzten session geöffnet hatten sind erneut geöffnet und Sie befinden sich auch wieder im working directory des Projekts. Projekte sind eine einfache und praktische Methode um Ihre Arbeiten zu organisieren und aufgeräumt zu halten. An dieser Stelle wäre es eventuell sinnnvoll, wenn Sie ein Projekt zu diesem Seminar erstellen. Sie könnten dann scripts für jedes Kapitel anlegen oder weitere Unterordner für Übungen usw. einrichten. Ob dies für Sie eine sinnvolle Arbeitsweise ist, bleibt aber Ihnen überlassen. Wir sollten nun noch kurz über das working directory sprechen. Dieses wird zum Beispiel dann relevant, wenn Sie versuchen eine Datei direkt aus einem script heraus zu öffnen oder zu speichern. Geben Sie dabei keinen kompletten absoluten Pfad an, geht R immer davon aus, dass Sie sich auf das working directory beziehen. Arbeiten Sie in einem Projekt, ist das working directory automatisch das Hauptverzeichnis des Projekts. Mit getwd() gibt Ihnen R ihr aktuelles Arbeitsverzeichnis zurück. Ihr Arbeitsverzeichnis können Sie über “Session” &gt; “Set Working Directory” &gt; “Choose Directory…” oder mit der Funktion setwd() ändern, wobei der Pfad mit \"\" eingefasst zwischen die Klammern geschrieben wird. 2.1.3 Kommentare Einer der wichtigsten skills beim Schreiben von code, ist das Kommentieren des selbigen. Kommentare können wir direkt in scripts schreiben, diese werden jedoch nicht ausgeführt sondern dienen der Erläuterung und Strukturierung des codes. Einen Kommentar markieren wir mit einem oder mehreren # zu Beginn einer Zeile. Text der auf ein # folgt wird von R als Kommentar erkannt und entsprechend nicht ausgeführt. Wenn Sie über längere Zeit an einem Projekt arbeiten oder dieses nach längerer Zeit erneut öffnen, kann es für sie selbst manchmal schwierig sein nachzuvollziehen, was Sie mit ihrem code erreichen wollten. Gut kommentierter code erleichtert dies stark. Dies wird nochmals relevanter, wenn Sie ihren code mit anderen Personen teilen. Für die meisten Probleme in R bestehen eine Vielzahl möglicher Ansätze. Gut kommentierter code hilft Anderen zu verstehen, was ihr Ansatz ist. Hier können Sie die Zeit die Sie in das Kommentieren investieren als Respekt gegenüber der Zeit verstehen, die Andere investieren um Ihnen mit Ihrem code zu helfen. Ihnen wird eventuell aufgefallen sein, dass der output der code Blöcke auf dieser website mit ## beginnt. Im output Ihrer R console fehlen diese. Beim Erstellen der website mit dem package bookdown werden die Symbole automatisch im output eingefügt um das Kopieren und Einfügen der code Blöcke in Ihre scripts zu erleichtern. So wird der mit ## markierte output von R als Kommentar verstanden und nicht als Befehl ausgeführt. Dies ist oft praktisch, trotzdem empfehle ich weiterhin so viel wie möglich selbst zu Tippen und copy/paste spärlich zu verwenden. Hier ein Beispiel eines bereits bekannten code Blocks, diesmal mit Kommentaren versehen: # assigning objects a &lt;- 17 b &lt;- 4 # calculating the answer the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 # but what is the question? Verwenden Sie setwd() in Ihrem script, empfiehlt es sich, dies auszukommentieren bevor sie das script weitergeben. Andere Personen haben andere Ordnerstrukturen als Sie und können mit Ihrem individuellen setwd() nichts anfangen. Im besten Fall wird ihr setwd() nicht ausführbar sein, im schlechtesten bringen Sie die Ordnerstruktur einer anderen Person durcheinander. Ähnliches gilt für Befehle die etwas auf die Festplatte speichern, beispielsweise Datensätze oder exportierte Graphiken. Die R community ist grundsätzlich sehr bereitwillig auch Anfängern mit coding Problemen zu helfen. Wir sollten diese Bereitschaft damit würdigen gut kommentierten code weiterzugeben und davon abzusehen, in die Datenstruktur von anderen Personen einzugreifen. 2.1.4 Speichern Aus meiner Sicht ist es aus dem Blickwinkel reproduzierbarer Datenanalyse meist der beste Ansatz, ein script zu erstellen in dem die rohen Daten eingelesen, bereinigt, transformiert sowie statistisch und graphisch analysiert werden. So ist es jeder Person mit Zugriff auf die Daten und ihr script möglich, jeden ihrer Arbeitsschritte nachzuvollziehen und zu reproduzieren. Dies ist eine der Säulen transparenter wissenschaftlicher Praxis. Bei diesem Ansatz müssen wir also selten die Ergebnisse unserer Analysen als Datensatz abspeichern. Das script – die .R Datei – ist ausreichend. Es gibt aber auch Situationen in denen es sinnvoll sein kann, Ergebnisse abzuspeichern. Quantitative Textanalysen können bespielsweise sehr rechenintensiv sein. Bei der Anwendung fortgeschrittener Methoden im machine learning auf sehr große Datensätze, können schonmal mehrere Stunden bis Tage Rechenzeit anfallen. Auch wenn wir solche Zeitdmensionen in diesem Seminar nicht erreichen, kann es hilfreich sein auch die Ergebnisse einer Operation im niedrigen Minutenbereich abzuspeichern um Rechenzeit bei regelmäßiger Arbeit mit den Ergebnissen zu sparen. Die einfachste Möglichkeit ist es, zum Speichern das native R Datenformat “.RData” zu nutzen. Erstellen wir einen kurzen data frame um diesen gleich abzuspeichern: data &lt;- data.frame( name = c(&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;), age = c(42, 84, 24), size = c(1.68, 1.82, 1.74), retired = c(FALSE, TRUE, FALSE) ) Mit save() können wir “.RData” Dateien speichern. Dazu schreiben wir innerhalb der Klammern zunächst den Namen des Objekts – oder mehrerer Objekte mit c() zusammengefasst – gefolgt von einem , und dem Argument file = \"\". Innerhalb der \"\" legen wir einen Dateinamen mit einem optionalen Pfad fest. Eine Datei ohne angegebenen Pfad wird im aktuellen working directory gespeichert. save(data, file = &quot;peter_paul_mary.RData&quot;) Um die gespeicherten Daten wieder zu laden, nutzen wir die Funktion load() mit dem Namen bzw. Pfad der Datei als einziges Argument. load(&quot;peter_paul_mary.RData&quot;) So haben wir Daten in dem schnellen und gut komprimierten nativen “.RData” Format gespeichert. Der Nachteil ist, dass diese Daten auch nur in R genutzt werden können. Interessieren sie sich dafür, Daten in einem besser transportierbaren Format zu speichern, biete sich “.csv” an. Mehr dazu hier: https://jakobtures.github.io/web-scraping/files.html 2.2 tidyverse Weiter oben haben wir das tidyverse package installiert und geladen. Dieses wird uns durch das ganze Seminar begleiten. Das tiydverse ist eine beliebte Sammlung von R packages die einer gemeinsamen Philosophie der Funktionssyntax sowie der Datenstruktur folgen und dabei viele datenanalytische Arbeitsprozesse abdecken. Der Vorteil ist, dass Sie, sobald Sie die Grundlogik verstanden haben, sehr schnell auch weitere tidyverse packages verstehen werden. Dies ist letztlich Geschmackssache, aber aus meiner Sicht führt das Arbeiten mit dem tidyverse zu intuitiverem und flüßiger zu schreibendem R code, vor allem dank der pipe %&gt;%, die im nächsten Kapitel eingeführt wird. Für eine umfassendere Einführung in das tidyverse, bietet sich das Buch “R for Data Science” von Wickham &amp; Grolemund an, welches auch Online zugänglich ist: https://r4ds.had.co.nz/ Aktuell besteht das core tidyverse package aus acht individuellen packages. Diese werden alle automatisch geladen wenn wir library(tidyverse) schreiben. Das core tidyverse deckt einen Großteil der besonders regelmäßig auftretenden datenanalytischen Funktionalitäten ab. Dazu gehören das Einlesen, Reinigen und Transformieren von Daten, die angesprochene pipe oder die graphische Analyse. Im weiteren werden wir viele Funktionen aus dem core tidyverse sehr regelmäßig nutzen. Nebem dem core tidyverse besteht eine wachsende Zahl zugehöriger packages, welche nach den selben Grundsätzen funktionieren, dabei aber speziellere Aufgabenfelder abdecken. Auch diese wurden mit install.packages(\"tidyverse\") bereits installiert, müssen aber explizit geladen werden. Darunter beispielsweise lubridate zum Umgang mit Datumsangaben und eine Reihe von packages zum Einlesen bestimmter Datentypen. Eine volle Liste der tidyverse packages finden Sie unter: https://www.tidyverse.org/packages/ 2.2.1 tidy data Das tidyverse folgt einer geteilten Philosophie der Datenstruktur namens tidy data. Einfach ausgedrückt steht tidy data dafür, dass jede Variable eines Datensatz eine eigene Spalte in einer Tabelle bekommt und jede Beobachtung eine eigene Zeile. Die Werte zu den Kombinationen von Variablen und Beobachtungen stehen in den Zellen. Betrachten wir folgenden data frame, welcher aktuelle (04.09.2021) Umfragewerte für die Wahl zum 20. Bundestag enthält. Die Daten stammen von: https://www.wahlrecht.de/umfragen/index.htm ## Institut CDU_CSU SPD GRÜNE FDP LINKE AfD Sonstige ## 1 Kantar 21 25 19 11 7 11 6 ## 2 Infratest 20 25 16 13 6 12 8 Diese Darstellungsform ist uns sofort intuitiv verständlich. So sehen Tabellen in Excel oder in Zeitungen aus und die Darstellung ist kompakt und übersichtlich. Aber ist Sie auch tidy? Dazu müssen wir uns Gedanken darüber machen, welche Variablen die Tabelle enthält. Die erste Spalte bildet die Variable “Institut” ab. Dies macht Sinn. Die restlichen 7 Spalten enthalten die Umfragewerte für die 6 aktuell im Bundestag vertretenen Parteien sowie “Sonstige”. Wir haben also eigentlich 2 Variablen: “Umfragewert” und “Partei”, welche aktuell in 7 Spalten dargestellt werden. Sie erinnern sich, jede Variable bekommt in einem tidy Datensatz eine Spalte. Zudem werden die Werte der Variable “Partei” auch gar nicht als Werte in der Tabelle sondern in den Spaltennamen abgebildet. Die Tabelle ist also eindeutig nicht tidy. Vergleichen Sie dies zu folgendem data frame: ## Institut Partei Umfragewert ## 1 Kantar CDU_CSU 21 ## 2 Kantar SPD 25 ## 3 Kantar GRÜNE 19 ## 4 Kantar FDP 11 ## 5 Kantar LINKE 7 ## 6 Kantar AfD 11 ## 7 Kantar Sonstige 6 ## 8 Infratest CDU_CSU 20 ## 9 Infratest SPD 25 ## 10 Infratest GRÜNE 16 ## 11 Infratest FDP 13 ## 12 Infratest LINKE 6 ## 13 Infratest AfD 12 ## 14 Infratest Sonstige 8 Diese Darstellung ist tidy. Wir haben 3 Variablen “Institut”, “Partei” und “Umfragewert” die jeweils in einer eigenen Spalte stehen. Beobachtungen sind nun nicht mehr das komplette Set von Umfragewerten eines Umfrageinstituts, sondern der Umfragewert einer Partei bei einem Insitut. Das Ergebnis ist eine Tabelle die den Prinzipien der tidy data folgt, die uns auf den ersten Blick aber ungewohnt erscheint, da wir nicht daran gewohnt sind Daten in dieser Form darzustellen. Dies erfordert zu Beginn etwas Gewöhnung. Wir sollten aber auch bedenken, dass es an dieser Stelle nicht das Ziel ist eine schöne Tabelle zu präsentieren sondern ein Datenobjekt zu konstruieren welches uns die praktische und komfortabele Weiterarbeit mit den diversen tidyverse packages ermöglicht. Mehr zu den angedeuteten Prinzipien der tidy data finden Sie im entsprechenden Kapitel von “R for Data Science” von Wickham &amp; Grolemund: https://r4ds.had.co.nz/tidy-data.html. 2.2.2 Tibbles Das tibble package ist Teil des core tidyverse und bietet eine Alternative zur base R Darstellung von Tabellen als data frames. Dabei liegen viele der Unterschiede zwischen tibbles und data frames eher im Detail. Für uns sind vor allem die Art wie tibbles in die console gedruckt werden und wie das subsetting funktioniert relevant. Mehr zu beidem gleich. Eine ausführlichere Einführung finden Sie in “R for Data Science”: https://r4ds.had.co.nz/tibbles.html Tibbles erstellen wir dabei auf die selbe Weise wie data frames, nutzen dazu aber die Funktion tibble(). Dazu müssen wir aber zunächst das tibble beziehungsweise das tidyverse package, welches tibble enthält laden. Hier geben wir die Daten direkt bei der Erstellung des tibbles ein. Wie bei data frames können wir tibbles aber auch aus zuvor definierten Vektoren zusammensetzen. library(tidyverse) tibble(numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE)) ## # A tibble: 3 × 3 ## numbers strings logicals ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 zero FALSE ## 2 1 one TRUE ## 3 2 two TRUE Bevor wir den ouput betrachten, ein genereller Hinweis: Je länger unser code wird, desto unübersichtlicher wird er auch. Wir sollten längeren code deshalb über mehrere Zeilen aufteilen und durch Einrücken kennzeichnen welche code Segmente zusammengehörig sind. Das Einrücken übernimmt RStudio weitestgehend automatisch, wir können aber auch selbst tab stops hinzufügen oder entfernen um Zeilen einzurücken. Eine übersichtlicher formatierte, inhaltlich aber identische Version des vorangegangenen codes könne wie folgt aussehen: tibble( numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE) ) ## # A tibble: 3 × 3 ## numbers strings logicals ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 zero FALSE ## 2 1 one TRUE ## 3 2 two TRUE R interpretiert dies identisch zur Schreibweise in einer Zeile und weiß, dass alles zwischen der öffnenden und schließenden Klammer Teil der aufgerufenen Funktion ist. Lassen sie uns nun den output betrachten. Dieser ist grundsätzlich ähnlich zu dem output eines data frames, wobei 2 Unterschiede bestehen. Zum Einen wird der Datentyp einer Spalte unter deren Namen abgebildet. Zum Anderen werden längere tibbles verkürzt abgedruckt, wie wir später noch sehen werden. Data frames werden hingegen stets vollständig gedruckt, was bei großen Datenmengen nur dazu führt, dass in der console eigentlich nichts mehr lesbar ist. Ein weiterer wichtiger Unterschied besteht im subsetting von tibbles. Das subsetting mit [] gibt uns immer einen neuen tibble zurück, mit [[]] bekommen wir einen Vektor. Sind wir nur an Spalten interessiert, reicht es übrigens nur die Spaltenposition zwischen den Klammern einzutragen. So bekommen wir die komplette Spalte, also über alle Zeilen, zurück. Alternativ zur numerischen Position, können wir auch die Spaltennamen nutzen. Entweder zwischen den eckigen Klammern oder in der $-Notation. tbl_exmpl &lt;- tibble( numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE) ) str(tbl_exmpl[1]) ## tibble [3 × 1] (S3: tbl_df/tbl/data.frame) ## $ numbers: num [1:3] 0 1 2 str(tbl_exmpl[[1]]) ## num [1:3] 0 1 2 str(tbl_exmpl[[&quot;numbers&quot;]]) ## num [1:3] 0 1 2 str(tbl_exmpl$numbers) ## num [1:3] 0 1 2 Viele tidyverse Funktionen nutzen tibbles statt data frames – so auch die Funktionen des tidytext packages, welches wir im Verlaufe des Seminars ausgiebig nutzen werden –, und Funktionen aus anderen packages werden meist data frames zurückgeben. Wir können beide Datenobjekte aber auch konvertieren. Dazu nutzen wir die base R Funktion as.data.frame() bzw. die dplyr Funktion as_tibble(). str(tbl_exmpl) ## tibble [3 × 3] (S3: tbl_df/tbl/data.frame) ## $ numbers : num [1:3] 0 1 2 ## $ strings : chr [1:3] &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi [1:3] FALSE TRUE TRUE df_exmpl &lt;- as.data.frame(tbl_exmpl) str(df_exmpl) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ numbers : num 0 1 2 ## $ strings : chr &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi FALSE TRUE TRUE tbl_exmpl_2 &lt;- as_tibble(df_exmpl) str(tbl_exmpl_2) ## tibble [3 × 3] (S3: tbl_df/tbl/data.frame) ## $ numbers : num [1:3] 0 1 2 ## $ strings : chr [1:3] &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi [1:3] FALSE TRUE TRUE 2.2.3 Die Pipe %&gt;% Ein weiteres Element des tidyverse ist die sogenannte pipe %&gt;%. Diese ermöglicht das Aneinanderketten von Befehlen, wobei das Ergebnis des vorangegangenen Befehls an den nächsten weitergegeben wird. Dies klingt noch sehr abstrakt, betrachten wir also ein praktisches Beispiel. Folgender code hat das Ziel, für einen vektor von Zahlen einen auf eine Nachkommastelle gerundeten Mittelwert zu berechnen. Dazu müssen wir zunächt den Vektor erstellen und einem Objekt zuweisen, dann den Mittelwert berechnen und erneut einem Objekt zuweisen und in einem letzten Schritt das Runden mit der Funktion round() vornehmen. Das Argument digits = legt dabei die Anzahl der Nachkommastellen fest. data &lt;- c(4.8, 15.16, 23.42) mean_data &lt;- mean(data) round(mean_data, digits = 1) ## [1] 14.5 Dies funktioniert, wir mussten dazu aber auch jeden Zwischenschritt in ein neues Objekt speichern. Nutzen wir stattdessen die pipe, umgehen wir diese Notwendigkeit und schreiben gleichzeitig kompakteren und intuitiveren code. data &lt;- c(4.8, 15.16, 23.42) data %&gt;% mean() %&gt;% round(digits = 1) ## [1] 14.5 Die pipe nimmt das Ergebnis einer Zeile und gibt dieses an die nächste Zeile weiter. Betrachten wir dieses Beispiel Schritt für Schritt. Die erste pipe gibt das Objekt data an die nächste weiter. Hier wird die Funktion mean() aufgerufen. Wie Sie sehen, dieses mal ohne Argumente zwischen den Klammern. Trotzdem weiß R, dass mean() auf das Objekt data angewandt werden soll. Dies funktioniert, da die pipe immer das Ergebnis der vorangegangenen Zeile als erstes Argument der Funktion in der folgenden Zeile einfügt. So wird hier mean() tatsächlich auf das Objekt data angewandt. Das Ergebnis, der Mittelwert, wird durch die nächste pipe an die letzte Zeile weitergegeben und eneut als erstes Argument eingesetzt, hier in die Funktion round(). Die Rundung wird also auf den in der Zeile zuvor berechneten Mittelwert angewandt. Dies funktioniert reibungslos mit allen Funktionen, die ein Datenobjekt auf das sie angwandt werden sollen als erstes Argument nehmen, was sehr häufig der Fall ist, aber nicht immer. Der resultierende code ist intuitiver zu lesen und weniger schreibintensiv, insbesondere wenn Sie sich früh angewöhnen die pipe mit der Tastenkombination “Ctrl” + “Shift” + “M” einzufügen. Das Endergebnis einer pipe Operation können wir ebenfalls einem Objekt zuweisen. Die Objektzuweisung erfolt dabei allerdings bereits in der ersten Zeile. rounded_mean &lt;- data %&gt;% mean() %&gt;% round(digits = 1) Dies ist auf den ersten Blick etwas unintuitiv, da nicht data dem Objekt rounded_mean zugewiesen wird, sondern das Ergebnis der letzten Zeile, also der gerundetete Mittelwert. 2.3 Hilfe? 2.3.1 Hilfe! Wir haben nun bereits einige R Funktionen kennengelernt und eine ungefähre Idee davon, was diese machen. Wie bekommen wir aber weitere Informationen zu diesen und neuen Funktionen, zu deren Funktionsweise, den zugelassenen Argumenten oder den zurückgegebenen Ergebnissen? Der einfachste Weg ist das Nutzen der eingebauten Hilfefunktionalitäten in R. Dazu schreiben wir einfach ein ? vor den Namen einer Funktion zu der wir Hilfe benötigen. Die zugehörige Hilfedatei öffnet sich dann im “Help” Tab, rechts-unten. Versuchen wir dies für die Funktion rnorm(). ?rnorm() Die Hilfedatei gibt uns eine ganze reihe von Informationen. rnorm() ist Teil einer Familie von Funktionen die sich auf die Normalverteilung beziehen. Dabei ist die Funktionalität von rnorm() Zufallszahlen aus der Normalverteilung zu generieren. Wir sehen auch, dass wir der Funktion 3 Argumente geben können. Die Anzahl der zu erzeugenden Zufallszahlen n sowie Mittelwert mean und Standardabweichung sd der zugrundeliegenden Normalverteilung. Dabei ist zu erkennen, dass mean und sd die Standardwerte 0 beziehungsweise 1 haben. Diese werden automatisch eingesetzt, wenn wir sie im Funktionsaufruf nicht durch neue Werte ersetzen. n hat keinen Standardwert, hier müssen wir also einen Wert angeben wenn wir die Funktion aufrufen. rnorm(n = 10) ## [1] -0.66778769 -0.78362536 0.32033441 -0.22940923 -0.70019987 0.11841483 ## [7] 0.05779057 -1.49761431 -0.94530948 0.85144271 So bekommen wir 10 Zufallswerte aus der Normalverteilung mit dem Mittelwert 0 und der Standardabweichung 1. Da es sich um Zufallszahlen handelt, wird Ihr output von dem auf der website dargestellten abweichen. Möchten wir Mittelwert und Standardabweichung anpassen, können wir die entsprechenden Argumente nutzen um die Standardwerte durch andere zu ersetzen. rnorm(n = 10, mean = 10, sd = 0.5) ## [1] 9.921969 11.526795 9.900528 10.194163 8.714044 10.279425 10.057465 ## [8] 9.724574 10.092792 9.772468 Neben der Hilfefunktion, stellen viele packages sogenannte vignettes bereit, Hilfedateien die in die Funktionalitäten des packages einführen. Schauen wir uns dies für das tibble package an: vignette(package = &quot;tibble&quot;) Wir bekommen so eine Liste mit allen zu tibble verfügbaren vignettes zurück. Einzelne dieser vignettes, rufen wir wie folgt auf: vignette(&quot;types&quot;) Eine ausführlichere Dokumentation zu einem package, finden Sie meist auf der dazugehörigen CRAN Seite, hier z.B. für tibble: https://cran.r-project.org/web/packages/tibble/index.html. 2.3.2 Empfohlene externe Resourcen Es gibt eine Vielzahl von websites und Büchern zu R und RStudio. Einige davon möchte ich hier vorstellen. Die website von RStudio umfasst eine große Sammlung von Resourcen zu R und der Arbeit mit spezfischen packages, darunter auch viele Webinars und tutorial Videos. Diese finden sie unter dem Menüpunkt “Resources” auf: https://www.rstudio.com/ Die RStudio cheatsheets zu einigen der beliebteren packages bieten auf kleinem Raum meist sehr gut zusammengefasste Informationen zu den Funktionen und der Arbeitsweise eines packages: https://www.rstudio.com/resources/cheatsheets/ Eine weitere Sammlung von tutorials zu unterschiedlichsten R Themen finden Sie auf “R-bloggers”: https://www.r-bloggers.com/ Generell finden Sie im Internet eine kaum überschaubare Fülle von Informationen und Resourcen zu R und spezifischen packages in Form von Videos, Blogs, digitalen Büchern und vor allem auch Foreneinträgen – beispielsweise auf https://stackoverflow.com/. So ist einer der wichtigsten Skills den Sie entwickeln müssen das Formulieren von klaren und kurzen Suchanfragen zu Ihrem spezifischen R Problem. In der Regel können Sie davon ausgehen, dass die Antwort bereits im Netz existiert. Ihre Aufgabe ist es nun, ihr Problem gut genug zu verstehen und eine entsprechende Suchanfrage zu Schreiben um auf diese wertvollen Resourcen zugreifen zu können. Das Internet gibt Ihnen ebenfalls Zugang zu einer Vielzahl umfassender Einführungen in R sowie zu Online Versionen von R Büchern: Intro to R for Social Scientists von Jasper Tjaden. Eine an Einsteiger gerichtete Einführung in R, die über das in diesem Seminar gelernte R Basiswissen hinausgeht. Geschrieben als Begleitmaterial zu einem Seminar an der Universität Potsdam im Sommersemester 2021. https://jaspertjaden.github.io/course-intro2r/ R Cookbook, 2nd Edition von J.D. Long &amp; Paul Teetor. Das Kochbuch besteht aus einer Reihe von Rezepten für spezifische Aufgaben die Sie in R durchführen möchten. Dies ist weniger als durchgängig zu lesendes Buch und mehr als Nachschlagewerk zu nutzen. https://rc2e.com/ R for Data Science von Hadley Wickham &amp; Garrett Grolemund. Eine Einführung in die Datenanalyse mit R, fokussiert auf die Arbeit mit dem tidyverse. Geschrieben von zwei Zentralen Figuren des tidyverse und Mitarbeitern bei RStudio. https://r4ds.had.co.nz/ "],["R3.html", "3 dplyr 3.1 Die Stammdaten des 19. Bundestags 3.2 Data wrangling mit dplyr", " 3 dplyr 3.1 Die Stammdaten des 19. Bundestags Dieses Kapitel behandelt die Bereinigung, Transformation und deskriptive statistische Analyse von Daten mit dplyr, sowie deren graphische Analyse mit ggplot2. Zur Veranschaulichung der Arbeitsschritte, analysieren wir eine Auswahl biographischer Daten der Bundestagsabgeordneten des 19. Bundestags. Die Daten stammen aus einer vom Bundestag bereitgestellten “.xml” Datei und wurden am 07.09.2021 von folgender URL heruuntergeladen: https://www.bundestag.de/services/opendata Das script zur Extraktion der interessierenden Variablen aus den XML Daten und der Konstruktion des hier genutzten tibbles, finden Sie in meinem GitHub: https://github.com/JakobTures/quanti-text/blob/master/scripts/stammdaten.R Das script speichert den tibble in der Datei “stammdaten.RData”, die von Seminarteilnehmern auch in Moodle heruntergeladen werden kann. Laden wir diese Daten zunächst in R. Da es sich bei dem zu ladenden Datenobjekt um einen tibble handelt, müssen wir auch zunächst das tidyverse package laden. R kennt ohne dieses keine tibble und interpretiert das Objekt als data frame. library(tidyverse) load(&quot;stammdaten.RData&quot;) Die Datei enthielt als Einziges das Objekt stammdaten, einen tibble der die ausgewählten Stammdaten aller jetzigen und ehemaligen Bundestagsabgeordneten enthält. Schauen wir uns den tibble einmal an: stammdaten ## # A tibble: 4,089 × 8 ## nachname vorname Titel Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. Dr. CDU 5 11 86 20.10.1930 ## 2 Achenbach Ernst Dr. FDP 3 7 108 09.04.1909 ## 3 Ackermann Annemarie &lt;NA&gt; CDU 2 4 104 26.05.1913 ## 4 Ackermann Else Dr. CDU 11 12 83 06.11.1933 ## 5 Adam Ulrich &lt;NA&gt; CDU 12 16 67 09.06.1950 ## 6 Adams Rudolf &lt;NA&gt; SPD 5 8 97 10.11.1919 ## 7 Adelmann Raban &lt;NA&gt; CDU 3 3 104 28.09.1912 ## 8 Adenauer Konrad Dr. CDU 1 5 141 05.01.1876 ## 9 Adler Brigitte &lt;NA&gt; SPD 11 14 73 22.06.1944 ## 10 Adorno Eduard &lt;NA&gt; CDU 4 6 96 31.10.1920 ## # … with 4,079 more rows Der tibble enthält 4089 Zeilen, also Daten zu 4089 Abgeordneten. Zu jeder Beobachtung, stehen 8 Variablen bereit. Nachname, Vorname, akademischer Titel, Parteizugehörigkeit, die erste und letzte Wahlperiode in der das MdB im Bundestag vertreten war sowie Alter und Geburtsdatum. Wie Sie sehen, werden bei tibbles standardmäßig nur die ersten 10 Zeilen gedruckt. Die Darstellung ist dadurch kompakt und übersichtlich, eventuell könnten wir aber daran interessiert sein mehr als 10 Zeilen zu sehen. Ein Weg ist das anklicken des Objekts im “Environment” Tab oder das äquivalente Schreiben von View(objektname) in der console. Nun öffnet sich das Objekt in einem neuen Tab und kann komplett betrachtet werden. Ein anderer Weg ist es R zu zwingen mehr Zeilen in die console abzudrucken. Dies ist mit der Funktion print() möglich. Als zweites Argument können wir mir n = angeben, wie viele Zeilen wir sehen möchten. print(stammdaten, n = 20) ## # A tibble: 4,089 × 8 ## nachname vorname Titel Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. Dr. CDU 5 11 86 20.10.1930 ## 2 Achenbach Ernst Dr. FDP 3 7 108 09.04.1909 ## 3 Ackermann Annemarie &lt;NA&gt; CDU 2 4 104 26.05.1913 ## 4 Ackermann Else Dr. CDU 11 12 83 06.11.1933 ## 5 Adam Ulrich &lt;NA&gt; CDU 12 16 67 09.06.1950 ## 6 Adams Rudolf &lt;NA&gt; SPD 5 8 97 10.11.1919 ## 7 Adelmann Raban &lt;NA&gt; CDU 3 3 104 28.09.1912 ## 8 Adenauer Konrad Dr. CDU 1 5 141 05.01.1876 ## 9 Adler Brigitte &lt;NA&gt; SPD 11 14 73 22.06.1944 ## 10 Adorno Eduard &lt;NA&gt; CDU 4 6 96 31.10.1920 ## 11 Aerssen Jochen Dr. CDU 8 9 76 15.04.1941 ## 12 Agatz Willi &lt;NA&gt; KPD 1 1 113 10.06.1904 ## 13 Ahlers Conrad &lt;NA&gt; SPD 7 8 94 08.11.1922 ## 14 Ahrens Adolf &lt;NA&gt; DP 1 1 138 17.09.1879 ## 15 Ahrens Hermann &lt;NA&gt; SPD 5 5 115 08.04.1902 ## 16 Ahrens Karl Dr. SPD 6 11 93 13.03.1924 ## 17 Aigner Heinrich Dr. CSU 3 8 93 25.05.1924 ## 18 Alber Siegbert Prof. Dr. CDU 6 8 81 27.07.1936 ## 19 Albers Johannes &lt;NA&gt; CDU 1 2 127 08.03.1890 ## 20 Albertz Luise &lt;NA&gt; SPD 1 5 116 22.06.1901 ## # … with 4,069 more rows 3.2 Data wrangling mit dplyr Das dplyr package enthält eine Reihe von Funktionen zur Bereinigung, Transformation und deskriptiven Analyse von Daten. Wir beginnen damit, Zeilen und Spalten die wir nicht benötigen aus dem tibble zu entfernen, bevor wir die Daten in einigen bestehenden Spalten transformieren und neue Spalten aus den vorhandenen Daten erzeugen sowie gruppierte Zusammenfassungen der Daten berechnen. 3.2.1 filter() filter() dient dazu, Beobachtungen – also Zeilen – aus einem tibble zu filtern. Die Funktion nimmt dabei die Daten auf die es angewandt werden soll als erstes und eine oder mehrere expressions als zweites Argument. Diese Ausdrücke sind letztlich die Regeln, nach denen die Funktion filtern soll. Zum Schreiben der Ausdrücke benötigen wir vergleichende Operatoren. Diese vergleichen den Wert auf der linken Seite des Operators mit dem auf der rechten, und geben als Ergebnis ein TRUE zurück wenn der Test bestanden wurde bwziehungsweise FALSE wenn er nicht bestanden wurde. Um zu testen ob zwei Werte gleich sind, nutzen wir den Operator ==. Bitte beachten Sie, dass wir zwei Gleichheitszeichen nutzen müssen. == vergleicht zwei Werte, während = den Wert auf der linken Seite mit dem auf der rechten Seite überschreibt. Möchten wir testen ob zwei Werte nicht gleich sind, nutzen wir !=. 42 == 42 ## [1] TRUE 42 != 42 ## [1] FALSE Ebenfalls können wir vergleichen ob der linke Werte kleiner &lt;, kleiner-gleich &lt;=, größer &gt; oder größer-gleich &gt;= ist. 10 &lt; 42 ## [1] TRUE 42 &lt;= 42 ## [1] TRUE 10 &gt; 42 ## [1] FALSE 90 &gt;= 42 ## [1] TRUE Wir könnten nun beispielsweise daran interessiert sein, nur die Daten bestimmter Parteien zu analysieren. Filtern wir zunächst die Stammdaten der CDU-Abgeordneten heraus. Wir können dazu in filter() testen, ob der Wert der Spalte “Partei” gleich dem Wert “CDU” ist. stammdaten %&gt;% filter(Partei == &quot;CDU&quot;) ## # A tibble: 1,347 × 8 ## nachname vorname Titel Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. Dr. CDU 5 11 86 20.10.1930 ## 2 Ackermann Annemarie &lt;NA&gt; CDU 2 4 104 26.05.1913 ## 3 Ackermann Else Dr. CDU 11 12 83 06.11.1933 ## 4 Adam Ulrich &lt;NA&gt; CDU 12 16 67 09.06.1950 ## 5 Adelmann Raban &lt;NA&gt; CDU 3 3 104 28.09.1912 ## 6 Adenauer Konrad Dr. CDU 1 5 141 05.01.1876 ## 7 Adorno Eduard &lt;NA&gt; CDU 4 6 96 31.10.1920 ## 8 Aerssen Jochen Dr. CDU 8 9 76 15.04.1941 ## 9 Alber Siegbert Prof. Dr. CDU 6 8 81 27.07.1936 ## 10 Albers Johannes &lt;NA&gt; CDU 1 2 127 08.03.1890 ## # … with 1,337 more rows Möchten wir mehrere Ausdrücke kombinieren, benötigen wir dazu logische Operatoren. &amp; – UND – testet ob beide verbundenen Ausdrücke gleichzeitig TRUE sind und gibt nur dann TRUE zurück. | – ODER – testet ob wenigstens einer der verbundenen Ausdrücke TRUE ist und gibt in diesem fall TRUE zurück. Dies sind alle möglichen Kombinationen für 2 Ausdrücke: TRUE &amp; TRUE gibt TRUE zurück TRUE &amp; FALSE, FALSE &amp; TRUE und FALSE &amp; FALSE geben alle FALSE zurück TRUE | TRUE, TRUE | FALSE und FALSE | TRUE geben alle TRUE zurück FALSE | FALSE gibt FALSE zurück Möchten wir nun beispielsweise alle CDU-Mitglieder des 19. Bundestags filtern, können wir dazu den &amp; Operator einsetzen: stammdaten %&gt;% filter(Partei == &quot;CDU&quot; &amp; letzte_WP == 19) ## # A tibble: 201 × 8 ## nachname vorname Titel Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 Bleser Peter &lt;NA&gt; CDU 12 19 65 23.07.1952 ## 2 Fuchtel Hans-Joachim &lt;NA&gt; CDU 11 19 65 13.02.1952 ## 3 Kauder Volker &lt;NA&gt; CDU 12 19 68 03.09.1949 ## 4 Landgraf Katharina &lt;NA&gt; CDU 11 19 63 24.02.1954 ## 5 Merkel Angela Dr. CDU 12 19 63 17.07.1954 ## 6 Schäuble Wolfgang Dr. CDU 7 19 75 18.09.1942 ## 7 Stübgen Michael &lt;NA&gt; CDU 12 19 57 17.10.1959 ## 8 Altmaier Peter &lt;NA&gt; CDU 13 19 59 18.06.1958 ## 9 Gröhe Hermann &lt;NA&gt; CDU 13 19 56 25.02.1961 ## 10 Grund Manfred &lt;NA&gt; CDU 13 19 62 03.07.1955 ## # … with 191 more rows Statt mit &amp; können wir in filter() Ausdrücke auch mit , verbinden. Das | lässt sich aber nicht auf ähnlichem Weg ersetzen. Möchten wir Unionsmitglieder filtern, also CDU- und CSU-Mitglieder, können wir dies mit | realisieren: stammdaten %&gt;% filter(Partei == &quot;CDU&quot; | Partei == &quot;CSU&quot;) ## # A tibble: 1,616 × 8 ## nachname vorname Titel Partei erste_WP letzte_WP alter geb ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 Abelein Manfred Prof. Dr. CDU 5 11 86 20.10.1930 ## 2 Ackermann Annemarie &lt;NA&gt; CDU 2 4 104 26.05.1913 ## 3 Ackermann Else Dr. CDU 11 12 83 06.11.1933 ## 4 Adam Ulrich &lt;NA&gt; CDU 12 16 67 09.06.1950 ## 5 Adelmann Raban &lt;NA&gt; CDU 3 3 104 28.09.1912 ## 6 Adenauer Konrad Dr. CDU 1 5 141 05.01.1876 ## 7 Adorno Eduard &lt;NA&gt; CDU 4 6 96 31.10.1920 ## 8 Aerssen Jochen Dr. CDU 8 9 76 15.04.1941 ## 9 Aigner Heinrich Dr. CSU 3 8 93 25.05.1924 ## 10 Alber Siegbert Prof. Dr. CDU 6 8 81 27.07.1936 ## # … with 1,606 more rows Es lassen sich auch mehr als zwei Ausdrücke mit &amp;und | kombinieren. Die Daten enthalten aktuell noch alle Abgeordneten die jemals ein Mandat im Bundestag hatten. Mit filter() können wir den Datensatz auf diejenigen reduzieren, die auch im 19. Bundestag vertreten waren. stammdaten_19 &lt;- stammdaten %&gt;% filter(letzte_WP == 19) Ab hier arbeiten wir mit dem Objekt stammdaten_19 weiter. 3.2.2 select() Möchten wir ein subset von Variablen bilden, könne wir dazu select() nutzen. Die Funktion nimmt die Daten auf die sie angewendet werden soll als erstes Argument – hier weitergegeben durch die pipe – und dann einen oder mehrere Spaltennamen, die im tibble verbleiben sollen. Folgen die zu behaltenden Spalten aufeinander, können wir auch eine “von:bis” Notation nutzen. Nehmen wir an, wir möchten Die Spalten “nachname”, “vorname”, “Titel” und “Partei” extrahieren: stammdaten_19 %&gt;% select(nachname, vorname, Titel, Partei) ## # A tibble: 732 × 4 ## nachname vorname Titel Partei ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Bleser Peter &lt;NA&gt; CDU ## 2 Brecht Eberhard Dr. SPD ## 3 Dehm Diether Dr. DIE LINKE. ## 4 Fuchtel Hans-Joachim &lt;NA&gt; CDU ## 5 Gysi Gregor Dr. DIE LINKE. ## 6 Jelpke Ulla &lt;NA&gt; DIE LINKE. ## 7 Kauder Volker &lt;NA&gt; CDU ## 8 Kubicki Wolfgang &lt;NA&gt; FDP ## 9 Landgraf Katharina &lt;NA&gt; CDU ## 10 Matschie Christoph &lt;NA&gt; SPD ## # … with 722 more rows stammdaten_19 %&gt;% select(nachname:Titel, Partei) ## # A tibble: 732 × 4 ## nachname vorname Titel Partei ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Bleser Peter &lt;NA&gt; CDU ## 2 Brecht Eberhard Dr. SPD ## 3 Dehm Diether Dr. DIE LINKE. ## 4 Fuchtel Hans-Joachim &lt;NA&gt; CDU ## 5 Gysi Gregor Dr. DIE LINKE. ## 6 Jelpke Ulla &lt;NA&gt; DIE LINKE. ## 7 Kauder Volker &lt;NA&gt; CDU ## 8 Kubicki Wolfgang &lt;NA&gt; FDP ## 9 Landgraf Katharina &lt;NA&gt; CDU ## 10 Matschie Christoph &lt;NA&gt; SPD ## # … with 722 more rows Wir können select()auch nutzen um Variablen zu entfernen. Dazu schreiben wir - vor den zu entfernenden Spaltennamen. Da das genaue Geburtsdatum der Abgeordneten im Folgenden nicht mehr benötigt wird, können wir die Spalte “geb” entfernen. stammdaten_19 &lt;- stammdaten_19 %&gt;% select(-geb) stammdaten_19 ## # A tibble: 732 × 7 ## nachname vorname Titel Partei erste_WP letzte_WP alter ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Bleser Peter &lt;NA&gt; CDU 12 19 65 ## 2 Brecht Eberhard Dr. SPD 12 19 67 ## 3 Dehm Diether Dr. DIE LINKE. 12 19 67 ## 4 Fuchtel Hans-Joachim &lt;NA&gt; CDU 11 19 65 ## 5 Gysi Gregor Dr. DIE LINKE. 11 19 69 ## 6 Jelpke Ulla &lt;NA&gt; DIE LINKE. 12 19 66 ## 7 Kauder Volker &lt;NA&gt; CDU 12 19 68 ## 8 Kubicki Wolfgang &lt;NA&gt; FDP 12 19 65 ## 9 Landgraf Katharina &lt;NA&gt; CDU 11 19 63 ## 10 Matschie Christoph &lt;NA&gt; SPD 12 19 56 ## # … with 722 more rows 3.2.3 rename() Ihnen wird eventuell bereits aufgefallen sein, dass die meisten Spaltennamen mit einem kleingeschriebenen Buchstaben beginnen, “Titel” und “Partei” aber nicht. Da habe ich anscheinend beim Erstellen des Datenobjekts meine eigenen Namenskonventionen – alles beginnt mit kleinen Buchstaben – ausser Acht gelassen. Um diese nun umzubenennen, können wir rename() nutzen. Erneut werden als erstes Argument die Daten durch die pipe weitergegeben, gefolgt von einem oder mehreren Argumenten in der Form neuer_name = alter_name. stammdaten_19 &lt;- stammdaten_19 %&gt;% rename(titel = Titel, partei = Partei) stammdaten_19 ## # A tibble: 732 × 7 ## nachname vorname titel partei erste_WP letzte_WP alter ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Bleser Peter &lt;NA&gt; CDU 12 19 65 ## 2 Brecht Eberhard Dr. SPD 12 19 67 ## 3 Dehm Diether Dr. DIE LINKE. 12 19 67 ## 4 Fuchtel Hans-Joachim &lt;NA&gt; CDU 11 19 65 ## 5 Gysi Gregor Dr. DIE LINKE. 11 19 69 ## 6 Jelpke Ulla &lt;NA&gt; DIE LINKE. 12 19 66 ## 7 Kauder Volker &lt;NA&gt; CDU 12 19 68 ## 8 Kubicki Wolfgang &lt;NA&gt; FDP 12 19 65 ## 9 Landgraf Katharina &lt;NA&gt; CDU 11 19 63 ## 10 Matschie Christoph &lt;NA&gt; SPD 12 19 56 ## # … with 722 more rows 3.2.4 mutate() mutate() dient dazu Daten in bestehenden Spalten zu transformieren und neue Spalten aus den Daten bestehender Spalten zu generieren. Aktuell ist der Name über zwei Spalten verteilt. Möchten wir stattdessen eine Spalte mit dem kompletten Namen erstellen, können wir dies mit mutate() umsetzen. Generell schreiben wir innerhalb der Klammern den Namen der zu transformierenden oder neu zu erstellenden Spalte = einem Ausdruck der beschreibt, wir die Daten transformiert oder generiert werden sollen. Dies kann eine einfache Berechnung wie mutate(neue_spalte = spalte_a + spalte b) sein, aber auch weitere Funktionen beinhalten. Hier nutzen wir die Funktion str_c() aus dem core tidyverse package stringr um zwei Strings zu einem zu kombinieren. Das optionale Argument sep = wird dazu genutzt festzulegen, welche Zeichen zwischen die zu kombinierenden Strings eingefügt werden. Setzen wir dies um und betrachten die neue sowie die alten Spalten: stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(name = str_c(nachname, vorname, sep = &quot;, &quot;)) stammdaten_19 %&gt;% select(nachname, vorname, name) ## # A tibble: 732 × 3 ## nachname vorname name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Bleser Peter Bleser, Peter ## 2 Brecht Eberhard Brecht, Eberhard ## 3 Dehm Diether Dehm, Diether ## 4 Fuchtel Hans-Joachim Fuchtel, Hans-Joachim ## 5 Gysi Gregor Gysi, Gregor ## 6 Jelpke Ulla Jelpke, Ulla ## 7 Kauder Volker Kauder, Volker ## 8 Kubicki Wolfgang Kubicki, Wolfgang ## 9 Landgraf Katharina Landgraf, Katharina ## 10 Matschie Christoph Matschie, Christoph ## # … with 722 more rows Die Spalte “titel” listet aktuell die akademischen Titel der Abgeordneten. Liegt ein Titel vor, wird dieser benannt. Liegt keiner vor enthält die Spalte ein NA, die Repräsentation fehlender Werte in R. Für diese Analyse interessiert uns nur ob ein Titel vorliegt, aber nicht welcher. Dazu könnten wir eine neue Spalte generieren, welche einen logischen Vektor enthält der angibt ob ein Titel vorliegt, TRUE, oder nicht, FALSE. Dies ist eine sogenannte Dummyvariable. Zum generieren können wir die dplyr Funktion if_else() nutzen. Wir geben als erstes Argument eine Bedingung an die getestet wird. Hier !is.na(titel), was testet ob der Inhalt von “titel” nicht – angezeigt durch das ! – missing ist. Das zweite und dritte Argument geben an, was eingesetzt werden soll wenn die getestete Bedingung erfüllt beziehungsweise nicht erfüllt ist. Hier soll im ersten Fall TRUE, im zweiten FALSE eingesetzt werden. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(titel_dummy = if_else(!is.na(titel), TRUE, FALSE)) stammdaten_19 %&gt;% select(titel, titel_dummy) ## # A tibble: 732 × 2 ## titel titel_dummy ## &lt;chr&gt; &lt;lgl&gt; ## 1 &lt;NA&gt; FALSE ## 2 Dr. TRUE ## 3 Dr. TRUE ## 4 &lt;NA&gt; FALSE ## 5 Dr. TRUE ## 6 &lt;NA&gt; FALSE ## 7 &lt;NA&gt; FALSE ## 8 &lt;NA&gt; FALSE ## 9 &lt;NA&gt; FALSE ## 10 &lt;NA&gt; FALSE ## # … with 722 more rows Die Spalte “partei” ist auch als character vector abgelegt. Bei der Parteizugehörigkeit handelt es sich um eine kategoriale Variable. So gibt es nur eine begrenzte Anzahl möglicher Ausprägungen, nämlich die Namen der im 19. Bundestag vertretenen Parteien sowie die Kategorie “Parteilos”. Die Repräsentation kategorialer Variablen in R nennt sich factor. Das core tidyverse package forcats ermöglicht es uns Faktorvariablen anzulegen und zu manipulieren. Dies erleichtert vor allem die graphische Analyse im weiteren Verlauf des Kapitels. Der einfachste Weg ist es, R selbst auslesen zu lassen welche Kategorien in einer Variable vorhanden sind. Dazu wenden wir einfach die Funktion factor() innerhalb von mutate() auf eine Spalte an. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(partei = factor(partei)) Um herauszufinden welche Kategorien ein factor vector umfasst, nutzen wir levels(). levels(stammdaten_19$partei) ## [1] &quot;AfD&quot; &quot;BÜNDNIS 90/DIE GRÜNEN&quot; &quot;CDU&quot; ## [4] &quot;CSU&quot; &quot;DIE LINKE.&quot; &quot;FDP&quot; ## [7] &quot;Plos&quot; &quot;SPD&quot; Dies scheint funktioniert zu haben, es fallen aber auch zwei Probleme auf um die wir uns noch kümmern sollten. Erstens könnten wir daran interessiert sein die Union als ganzes zu analysiseren. Zweitens sind die Kategorien aktuell alphabetisch geordnet, inhaltlicher sinnvoller wäre aber beispielsweise eine Ordnung anhand der größe der Fraktionen im 19. Bundestag. Fassen wir zuerst “CDU” und “CDU” zur “Union” zusammen. Dazu können wir fct_collapse() nutzen. Dabei geben wir vor dem = den Namen der neuen Kategorie an, nach dem = mit c() kombiniert die Namen der alten Kategorien die wir zusammenfassen möchten. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(partei = fct_collapse(partei, Union = c(&quot;CDU&quot;, &quot;CSU&quot;))) levels(stammdaten_19$partei) ## [1] &quot;AfD&quot; &quot;BÜNDNIS 90/DIE GRÜNEN&quot; &quot;Union&quot; ## [4] &quot;DIE LINKE.&quot; &quot;FDP&quot; &quot;Plos&quot; ## [7] &quot;SPD&quot; Um die Kategorien manuell neu zu ordnen, könnten wir fct_relevel() nutzen. Dazu müssten wir aber die gewünschte Reihenfolge per Hand notieren. Bequemer geht es mit fct_infreq(), welche die Kategorien automatisch nach der Häufigkeit Ihres Auftretens in den Daten ordnet. Also in unserem Fall von der Kategorie mit den meisten Abgeordneten bis zu der mit den wenigsten. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(partei = fct_infreq(partei)) levels(stammdaten_19$partei) ## [1] &quot;Union&quot; &quot;SPD&quot; &quot;AfD&quot; ## [4] &quot;FDP&quot; &quot;BÜNDNIS 90/DIE GRÜNEN&quot; &quot;DIE LINKE.&quot; ## [7] &quot;Plos&quot; Damit sind die Daten zur weiteren Analyse vorbereitet. Wir können nun noch nicht mehr benötigte Spalten entfernen um den tibble übersichtlich zu halten, sowie die dann noch vorhandenen Spalten in eine sinnvollere Reihenfolge bringen. Beides ist nicht zwingend notwendig, führt aber zu einem aufgeräumteren output des tibbles. Die Spalten “nachname”, “vorname” und “titel” sind nicht mehr notwendig, da wir die enthaltenen Informationen in neue Variablen überführt haben. stammdaten_19 &lt;- stammdaten_19 %&gt;% select(-c(nachname:titel)) stammdaten_19 ## # A tibble: 732 × 6 ## partei erste_WP letzte_WP alter name titel_dummy ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 Union 12 19 65 Bleser, Peter FALSE ## 2 SPD 12 19 67 Brecht, Eberhard TRUE ## 3 DIE LINKE. 12 19 67 Dehm, Diether TRUE ## 4 Union 11 19 65 Fuchtel, Hans-Joachim FALSE ## 5 DIE LINKE. 11 19 69 Gysi, Gregor TRUE ## 6 DIE LINKE. 12 19 66 Jelpke, Ulla FALSE ## 7 Union 12 19 68 Kauder, Volker FALSE ## 8 FDP 12 19 65 Kubicki, Wolfgang FALSE ## 9 Union 11 19 63 Landgraf, Katharina FALSE ## 10 SPD 12 19 56 Matschie, Christoph FALSE ## # … with 722 more rows Was eine sinnvolle Reihenfolge der verbleibenden Variablen sein kann ist natürlich subjektiv, Ich würde aber folgende Reihenfolge vorschlagen und mit relocate() umsetzen. Die Syntax funktioniert dabei ähnllich zu select(). stammdaten_19 &lt;- stammdaten_19 %&gt;% relocate(name, titel_dummy, partei, alter, erste_WP, letzte_WP) stammdaten_19 ## # A tibble: 732 × 6 ## name titel_dummy partei alter erste_WP letzte_WP ## &lt;chr&gt; &lt;lgl&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Bleser, Peter FALSE Union 65 12 19 ## 2 Brecht, Eberhard TRUE SPD 67 12 19 ## 3 Dehm, Diether TRUE DIE LINKE. 67 12 19 ## 4 Fuchtel, Hans-Joachim FALSE Union 65 11 19 ## 5 Gysi, Gregor TRUE DIE LINKE. 69 11 19 ## 6 Jelpke, Ulla FALSE DIE LINKE. 66 12 19 ## 7 Kauder, Volker FALSE Union 68 12 19 ## 8 Kubicki, Wolfgang FALSE FDP 65 12 19 ## 9 Landgraf, Katharina FALSE Union 63 11 19 ## 10 Matschie, Christoph FALSE SPD 56 12 19 ## # … with 722 more rows 3.2.5 summarise() &amp; group_by() Die Funktion summarise() ermöglicht es uns, zusammenfassende Maßzahlen zu einem tibble zu berechnen. Die Syntax funktioniert dabei ähnlich zu mutate(). Wir definieren einen Namen für die Spalte in der die Maßzahlen gelistet werden sollen und nach dem = eine entsprechende Berechnung oder Funktion. Das Ergebnis ist ein neuer tibble der die angeforderten Statistiken enthält. Betrachten wir zunächst die Spalte “alter”. Wir könnten uns für das arithmetische Mittel des Alters der MdBs interessieren. Dazu definieren wir innerhalb von summarise() den Namen der neuen Spalte und nach dem = nutzen wir die base R Funktion mean(): stammdaten_19 %&gt;% summarise(arith_mittel = mean(alter)) ## # A tibble: 1 × 1 ## arith_mittel ## &lt;dbl&gt; ## 1 49.3 Wir können uns auch mehrere Statistiken gleichzeitig ausgeben, indem wir die entsprechenden Anfragen mit , verbinden: stammdaten_19 %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), median = median(alter), maximum = max(alter)) ## # A tibble: 1 × 4 ## minimum arith_mittel median maximum ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 24 49.3 50 77 Das sieht alles schon ordentlich aus, ist aber auch auf einfacherem Wege erzielbar, beispielsweise mit der praktischen base R Funktion summary(). Wirklich mächtig wird summarise() erst durch die Kombination mit group_by(). So können wir die Daten gruppieren und die zusammenfassenden Statistiken für jede dieser Gruppen separat berechnen. Unsere Daten bieten sich für eine Analyse nach Parteimitgliedschaft an. Als ersten Schritt können wir die Daten also nach dem Inhalt der Spalte “partei” gruppieren und zunächst einmal Zählen, wie viele Abgeordnete pro Partei im Bundestag vertreten sind. Dazu nutzen wir innerhalb von mutate() die dplyr Funktion n(), welche die Gruppengröße, also die Anzahl beobachtungen pro Gruppe, zurückgibt. stammdaten_19 %&gt;% group_by(partei) %&gt;% summarise(abgeordnete = n()) ## # A tibble: 7 × 2 ## partei abgeordnete ## &lt;fct&gt; &lt;int&gt; ## 1 Union 248 ## 2 SPD 162 ## 3 AfD 88 ## 4 FDP 84 ## 5 BÜNDNIS 90/DIE GRÜNEN 71 ## 6 DIE LINKE. 69 ## 7 Plos 10 Weiter oben haben wir das Durchschnittsalter aller Abgeordneten berechnet. Dies können wir natürlich auch gruppiert nach der Partei machen. stammdaten_19 %&gt;% group_by(partei) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter)) ## # A tibble: 7 × 6 ## partei minimum arith_mittel std_abweichung median maximum ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Union 24 49.9 9.69 50.5 75 ## 2 SPD 26 50.2 9.42 52 68 ## 3 AfD 26 50.8 12.5 49.5 77 ## 4 FDP 24 45.6 10.8 46 76 ## 5 BÜNDNIS 90/DIE GRÜNEN 32 47.1 9.67 48 64 ## 6 DIE LINKE. 27 50.1 9.73 52 69 ## 7 Plos 31 45.7 8.19 44.5 59 Oft ist es hilfreich die Daten nach einer Statistik die uns interessiert zu ordnen. Möchten wir beispielsweise Wissen, welche Partei den höchsten beziehungsweise niedrigsten Mittelwert des Alters hat, können wir die Ergebnisse in einem weiteren Schritt mit der Funktion arrange() nach den Werten einer Variable ordnen. Die zusätzliche Funktion desc() bewirkt, dass die Daten absteigend geordnet werden. stammdaten_19 %&gt;% group_by(partei) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter)) %&gt;% arrange(desc(arith_mittel)) ## # A tibble: 7 × 6 ## partei minimum arith_mittel std_abweichung median maximum ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 AfD 26 50.8 12.5 49.5 77 ## 2 SPD 26 50.2 9.42 52 68 ## 3 DIE LINKE. 27 50.1 9.73 52 69 ## 4 Union 24 49.9 9.69 50.5 75 ## 5 BÜNDNIS 90/DIE GRÜNEN 32 47.1 9.67 48 64 ## 6 Plos 31 45.7 8.19 44.5 59 ## 7 FDP 24 45.6 10.8 46 76 Die Spalte “titel_dummy” ist ein logischer Vektor der TRUE enthält, wenn ein MdB einen akademischen Titel besitzt und FALSE, wenn keiner vorliegt. Hinter einem logischen Vektor stehen Zahlenwerte. TRUE ist die Repräsentation von 1, FALSE von 0. Wir können also direkt mit den Werten des Vektors rechnen. Um die absolute Anzahl an Titeln zu berechenn, reicht es also Summe des Vektors zu bilden. Alle Werte des vektors werden aufaddiert und da wir nur Einsen und Nullen haben, ist das Ergebnis gleich der Anzahl der Abgeordneten die einen akademischen Titel tragen. Um den relativen Anteil zu berechnen, können wir das arithmetische Mittel nutzen. Alle Einsen und Nullen werden aufaddiert und durch die Anzahl der Beobachtungen geteilt. Dies ist der Anteil der Abgeordneten mit Titel. stammdaten_19 %&gt;% summarise(absolut = sum(titel_dummy), relativ = mean(titel_dummy) ) ## # A tibble: 1 × 2 ## absolut relativ ## &lt;int&gt; &lt;dbl&gt; ## 1 143 0.195 Wir könnten uns dafür interessieren, ob sich das Alter der Abgeordneten mit Titel von denen unterscheidet die keinen Titel tragen. Dazu gruppieren wir nach der Spalte “titel_dummy” und berechnen die Statistiken zum Alter. stammdaten_19 %&gt;% group_by(titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter)) ## # A tibble: 2 × 6 ## titel_dummy minimum arith_mittel std_abweichung median maximum ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 FALSE 24 48.9 10.1 49 77 ## 2 TRUE 28 50.8 10.8 50 76 Wir können auch nach mehreren Spalten gleichzeitig gruppieren. In diesem Fall werden die Statistiken für jede Gruppenkombination berechnet. stammdaten_19 %&gt;% group_by(partei, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter)) ## `summarise()` has grouped output by &#39;partei&#39;. You can override using the `.groups` argument. ## # A tibble: 14 × 7 ## # Groups: partei [7] ## partei titel_dummy minimum arith_mittel std_abweichung median maximum ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Union FALSE 24 49.6 9.71 51 70 ## 2 Union TRUE 32 51.0 9.63 50 75 ## 3 SPD FALSE 26 50.1 9.56 52 68 ## 4 SPD TRUE 33 50.8 8.83 49 67 ## 5 AfD FALSE 26 49.6 12.0 49 77 ## 6 AfD TRUE 28 54.8 13.5 55.5 76 ## 7 FDP FALSE 24 44.8 9.79 46 66 ## 8 FDP TRUE 31 48.7 13.9 46 76 ## 9 BÜNDNIS 90/DI… FALSE 32 48.1 9.75 49 64 ## 10 BÜNDNIS 90/DI… TRUE 33 43.8 8.87 42.5 64 ## 11 DIE LINKE. FALSE 27 48.7 9.72 50 66 ## 12 DIE LINKE. TRUE 48 56.8 6.67 56 69 ## 13 Plos FALSE 31 45.9 9.14 44.5 59 ## 14 Plos TRUE 42 45 4.24 45 48 An dieser Stelle müssen wir noch über eine Besonderheit in der Zusammenarbeit von group_by() und summarise() sprechen, welche zu Problemen führen kann, wenn Sie sich ihr nicht bewusst sind. Grundsätzlich wird jeder Aufruf von summarise() nach einem group_by() Befehl eine Ebene der Gruppierung auflösen. Für die Beispiele in denen wir nur nach Partei oder Titel gruppiert hhaben, bedeutet dies also, dass die Daten nach dem summarise() Befehl nicht mehr gruppiert waren. Wir hatten eine Gruppierungsebene und diese wurde automatisch entfernt. Im letzten Beispiel hatten wir zwei Gruppierungsebenen. Von diesen wurde nur die niedrigere Gruppierungsebene – die Reihenfolge der Variablen in group_by() bestimmt auch die reihenfolge der Gruppierung –, also die Gruppierung nach dem Titel aufgelöst. Die Gruppierung nach der Parteimitgliedschaft ist weiterhin aktiv. Dies ist auch im output anhand der Zeile # Groups: partei [7] erkennbar. Die Daten sind nach der Partei gruppiert und wir haben 7 Gruppen. Möchten wir mit den Ergebnissen dieser Berechnungen weiterarbeiten, müssen wir uns auch über die Gruppierung bewusst sein. Sollen die Daten weiterhin gruppiert sein? Dann ist alles gut, sollen sie es nicht sein müssen wir die Gruppierung vollständig auflösen. Dies machen wir mit der Funktion ungroup(). Solange Sie sich nicht sicher sind, dass Sie die Gruppierung wirklich weiterhin brauchen, würde ich immer zu einem ungroup() am Ende einer group_by() und summarise() Operation mit mehreren Gruppen tendieren. So verhindern sie versehentliche Berechnungen auf Gruppenbasis und die Gruppierung lässt sich jederzeit schnell wieder herstellen, sollten dies notwendig werden. # Groups: district [2]. Another summarise() function would compute the statistic by “district” and then remove this level as well. We can also use ungroup() to remove all grouping from a tibble. In the case of this example, it does not make a practical difference as we only compute the summary and then move on. But, if we assign the results of a summary to an object for later use, we have to decide if we want to remove the grouping or keep it in effect, depending on the goals of the analysis. In general, I would always ungroup the data and group it again if the need arises, as this is less error prone and just a minor increase in the amount of typing needed. stammdaten_19 %&gt;% group_by(partei, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter)) %&gt;% ungroup() ## `summarise()` has grouped output by &#39;partei&#39;. You can override using the `.groups` argument. ## # A tibble: 14 × 7 ## partei titel_dummy minimum arith_mittel std_abweichung median maximum ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Union FALSE 24 49.6 9.71 51 70 ## 2 Union TRUE 32 51.0 9.63 50 75 ## 3 SPD FALSE 26 50.1 9.56 52 68 ## 4 SPD TRUE 33 50.8 8.83 49 67 ## 5 AfD FALSE 26 49.6 12.0 49 77 ## 6 AfD TRUE 28 54.8 13.5 55.5 76 ## 7 FDP FALSE 24 44.8 9.79 46 66 ## 8 FDP TRUE 31 48.7 13.9 46 76 ## 9 BÜNDNIS 90/DI… FALSE 32 48.1 9.75 49 64 ## 10 BÜNDNIS 90/DI… TRUE 33 43.8 8.87 42.5 64 ## 11 DIE LINKE. FALSE 27 48.7 9.72 50 66 ## 12 DIE LINKE. TRUE 48 56.8 6.67 56 69 ## 13 Plos FALSE 31 45.9 9.14 44.5 59 ## 14 Plos TRUE 42 45 4.24 45 48 3.2.6 Speichern der Daten Wir werden im nächsten Kapitel mit den hier transformierten Daten weiterarbeiten. Dazu sollten Sie entweder zu Beginn des Kapitels das script aus diesem Kapitel nochmals durchlaufen lassen, oder sie speichern die bearbeiteten Daten: save(stammdaten_19, file = &quot;stammdaten_19.RData&quot;) 3.2.7 Export von Tabellen Das Exportieren von Tabellen – beispielsweise die oben berechneten Statistiken – aus R ist leider nicht ganz so einfach wie man denken oder hoffen würde. Wir können natürlich immer copy &amp; paste nutzen um die Werte in Word oder eine sonstige Software zu kopieren, dies aber nicht nur langweilige Fleißarbeit sondern auch fehleranfällig, vor allem bei umfassenderen Analysen als die, die wir bisher betrachet haben. Ein flexibler Weg zum direkten Export von Tabellen ist es, diese als “.csv” abzuspeichern. Diese Format kann wiedrum direkt in Excel und vermutlich auch in Word importiert werden. Da ich kein aktiver Office Nutzer bin, kann Ich Ihnen hier nur begrenzte praktische Ratschläge geben. Der Import sollte aber im Normalfall möglich sein. CSV steht für “comma-separated values”. Da diese sehr einfach gehalten sind und von einer großen Bandbreite an Software verarbeitet werden können, ist dies eines der meistgenutzten Datenformate. Die Grundstruktur ist dabei wie folgt: column1, column2, column3 data1_1, data1_2, data1_3 data2_1, data2_2, data2_3 data3_1, data3_2, data3_3 Die Zeilen einer Tabelle sind durch Zeilenumbrüche getrennt, die Spalten durch Kommas. So können wir beispielsweise das Ergebnis einer summarise() Operation mit write_csv() aus readr (core tidyverse) abspeichern. stammdaten_19 %&gt;% group_by(partei, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter)) %&gt;% ungroup() %&gt;% write_csv(file = &quot;alter_partei_titel_1.csv&quot;) ## `summarise()` has grouped output by &#39;partei&#39;. You can override using the `.groups` argument. Aus Gründen die vermutlich nur Microsoft selbst bekannt sind, können “.csv” Dateien in denen die Spalten durch Kommas getrennt sind – der internationale Standard – auf deutschen Windows Systemen nicht ohne weiteres importiert werden. Nutzen Sie statt Microsoft Office die open source Alternative Libre Office, ist das Problem bereits behoben. Möchten Sie aber Microsoft Office auf einem deutschen System nutzen, sollten Sie die Datei im Deutschen Standard – statt Kommas werden Semikolons als Trennzeichen der Spalten verwendet (die Kommas werden zur Darstellung von Dezimalzahlen benötigt) – speichern. Dies ist mit write_csv2() auf einfachem Wege möglich.. Mehr zu “.csv” Dateien finden sie unter: https://jakobtures.github.io/web-scraping/files.html 3.2.7.1 Weiterführende Resourcen Es existiert eine Vielzahl von packages die Funktionen zur Formatierung und dem Export von Tabellen mitbringen. Aus Platzgründen können wir nicht auf die Details eingehen, hier aber einige Startpunkte: Möchten sie direkt nach “.xlsx” exportieren, wären zwei der Optionen: * writexl: https://cran.r-project.org/web/packages/writexl/index.html * openxlsx: https://cran.r-project.org/web/packages/openxlsx/index.html Tabellen direkt im “.docx” Format zu erstellen ermöglicht flextable: https://davidgohel.github.io/flextable/ huxtable kann Tabellen im “.tex” Foramt zur Arbeit in LaTeX ausgeben: https://hughjonesd.github.io/huxtable/ Möchten sie externe Software zum Schreiben von Hausarbieten und Papers ganz umgehen, könnte R Markdown für Sie von Interesse sein. Dies ermöglicht das gleichzeitige Schreiben von Text und Code in einem Dokument. Die Ausgabe ist unter anderem in “.pdf” möglich und kann neben dem Text auch Code der dargettellt werden soll sowie Tabellen und Grafiken enthalten. Einige Resourcen zu R Markdown finden Sie hier: Einführung der RStudio website: https://rmarkdown.rstudio.com/lesson-1.html{target_“blank”} Das R Markdown cheat sheet: https://raw.githubusercontent.com/rstudio/cheatsheets/master/rmarkdown-2.0.pdf Kapitel zu R Markdown in “R for Data Science” von Hadley Wickham und Garrett Grolemund: https://r4ds.had.co.nz/r-markdown.html “R Markdown Cookbook” von Yihui Xie, Christophe Dervieux, Emily Riederer: https://bookdown.org/yihui/rmarkdown-cookbook/ Die Website die Sies aktuell betrachten sowie viele der verlinkten Resourcen sind mit bookdown geschrieben, welches auf R Markdown aufbaut und sich vor allem für umfangreichere Projekte eignet. “bookdown: Authoring Books and Technical Documents with R Markdown” von Yihui Xie: https://bookdown.org/yihui/bookdown/ "],["R4.html", "4 ggplot2 4.1 Graphische Analyse mit ggplot2", " 4 ggplot2 4.1 Graphische Analyse mit ggplot2 Wir arbeiten in diesem Kapitel mit den in Kapitel 3 transformierten Daten weiter. Dazu müssten Sie entweder das Script aus der Vorwoche nochmals durchführen, den unten stehenden code Block, welcher alle Veränderungen an den Daten in kompakter Form enthält ausführen, oder sie laden die Daten – vorausgesetzt Sie haben sie gespeichert. Vor dem Laden der Daten müssen wir erneut das tidyverse laden. library(tidyverse) load(&quot;scripts/stammdaten.RData&quot;) stammdaten_19 &lt;- stammdaten %&gt;% filter(letzte_WP == 19) %&gt;% rename(titel = Titel, partei = Partei) %&gt;% mutate(name = str_c(nachname, vorname, sep = &quot;, &quot;)) %&gt;% mutate(titel_dummy = if_else(!is.na(titel), TRUE, FALSE)) %&gt;% mutate(partei = factor(partei)) %&gt;% mutate(partei = fct_collapse(partei, Union = c(&quot;CDU&quot;, &quot;CSU&quot;))) %&gt;% mutate(partei = fct_infreq(partei)) %&gt;% select(-c(nachname:titel), -geb) %&gt;% relocate(name, titel_dummy, partei, alter, erste_WP, letzte_WP) 4.1.1 ggplot2 syntax 4.1.2 aesthetics &amp; geoms 4.1.3 Graphische Analyse der Stammdaten 4.1.3.1 kontinuierliches x &amp; y Alter vs. 1. WP Alter vs WPs (Übung) 4.1.3.2 kategoriales x Anzahl MdBs nach Partei Anzahl Titel nach Partei Anteil Titel nach Partei 4.1.3.3 kontinuierliches x Boxplot für Alter nach Partei Verteilung Alter übereinander nach facet? Verteilung WPs (+ nach facet -&gt;Übung) 4.1.4 Graphiken exportieren "],["BT19.html", "5 Plenarprotokolle des 19. Bundestags", " 5 Plenarprotokolle des 19. Bundestags "],["tidytext1.html", "6 tidytext format &amp; tokenisation", " 6 tidytext format &amp; tokenisation "],["tidytext2.html", "7 tf &amp; tf-idf", " 7 tf &amp; tf-idf "],["tidytext3.html", "8 n-grams &amp; correlations", " 8 n-grams &amp; correlations "],["tidytext4.html", "9 Sentiment Analyse", " 9 Sentiment Analyse "],["quanteda1.html", "10 corpus, tokenisation &amp; DTM", " 10 corpus, tokenisation &amp; DTM "],["quanteda2.html", "11 Anwendungsbeispiele 1", " 11 Anwendungsbeispiele 1 "],["quanteda3.html", "12 Anwendungsbeispiele 2", " 12 Anwendungsbeispiele 2 "],["ML1.html", "13 Unsupervised", " 13 Unsupervised "],["ML2.html", "14 Supervised", " 14 Supervised "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
